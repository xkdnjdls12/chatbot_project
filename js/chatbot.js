// OpenAI API 설정
let OPENAI_API_KEY = null; // .env 파일에서 로드됨
const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
//테스트
// DOM 요소들
let currentScenario = 1;
let userChoices = [];
let userReasons = []; // 사용자가 입력한 이유들을 저장

// 페이지 로드 시 초기화
document.addEventListener('DOMContentLoaded', async function() {
    await loadAPIKey();
    initializeChatbot();
    setupEventListeners();
});

// API 키 로드
async function loadAPIKey() {
    try {
        const envVars = await fetch('../env.json').then(response => response.json());
        OPENAI_API_KEY = envVars.OPEN_AI_KEY;
        
        
        if (OPENAI_API_KEY) {
            console.log('API 키 로드 성공:', OPENAI_API_KEY.substring(0, 10) + '...');
        } else {
            console.error('OPENAI_API 키를 찾을 수 없습니다.');
        }
    } catch (error) {
        console.error('API 키 로드 실패:', error);
    }
}

// 챗봇 초기화
function initializeChatbot() {
    console.log('챗봇이 시작되었습니다.');
    
    if (!OPENAI_API_KEY) {
        console.error('API 키가 로드되지 않았습니다.');
        showAPIKeyError();
        return;
    }
    
    // 초기 시나리오 설정
    updateScenario();
}

// 이벤트 리스너 설정
function setupEventListeners() {
    // 초기 선택 버튼들
    const choiceButtons = document.querySelectorAll('.choice-button');
    choiceButtons.forEach(button => {
        button.addEventListener('click', function() {
            handleInitialChoice(this);
        });
    });
    
    // 버튼들
    const submitReason = document.getElementById('submitReason');
    const backToActions = document.getElementById('backToActions');
    
    if (submitReason) {
        submitReason.addEventListener('click', submitUserReason);
    }
    
    if (backToActions) {
        backToActions.addEventListener('click', backToInitialChoices);
    }
    
    // 엔터키로 이유 제출
    const reasonInput = document.getElementById('reasonInput');
    if (reasonInput) {
        reasonInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                submitUserReason();
            }
        });
    }
}

// 초기 선택 처리 함수
function handleInitialChoice(button) {
    const choice = button.dataset.choice;
    const choiceText = button.textContent.trim();
    
    // 선택된 버튼 스타일 적용
    button.classList.add('selected');
    
    // 사용자 선택 저장
    userChoices.push({
        scenario: currentScenario,
        choice: choice,
        text: choiceText
    });
    
    console.log('사용자 선택:', choiceText);
    
    // 선택한 선택지 텍스트를 프롬프트에 표시
    const promptText = document.querySelector('.prompt-text');
    if (promptText) {
        promptText.textContent = choiceText;
    }
    
    // 초기 선택 버튼들 숨기고 이유 입력 창 표시
    document.getElementById('initialChoices').style.display = 'none';
    document.getElementById('inputPrompt').style.display = 'block';
    
    // 입력 필드에 포커스
    setTimeout(() => {
        document.getElementById('reasonInput').focus();
    }, 100);
}

// 초기 선택으로 돌아가기
function backToInitialChoices() {
    // 마지막 선택을 취소
    if (userChoices.length > 0) {
        userChoices.pop();
        console.log('선택 취소됨. 남은 선택:', userChoices);
    }
    
    // 이유 입력 창 숨기기
    document.getElementById('inputPrompt').style.display = 'none';
    
    // 초기 선택 버튼들 다시 표시
    document.getElementById('initialChoices').style.display = 'flex';
    
    // 선택된 버튼 스타일 제거
    const selectedButtons = document.querySelectorAll('.choice-button.selected');
    selectedButtons.forEach(button => {
        button.classList.remove('selected');
    });
    
    // 입력 필드 초기화
    const reasonInput = document.getElementById('reasonInput');
    if (reasonInput) {
        reasonInput.value = '';
    }
    
    console.log('초기 선택으로 돌아가기');
}

// 다음으로 진행
function proceedToNext() {
    // 이미 해당 시나리오의 이유가 저장되어 있는지 확인
    const existingReason = userReasons.find(reason => reason.scenario === currentScenario);
    
    if (!existingReason) {
        // "다음으로" 버튼 클릭 시 null로 처리 (이유가 없을 때만)
        userReasons.push({
            scenario: currentScenario,
            choice: userChoices[userChoices.length - 1].text,
            reason: null, // null 처리
            timestamp: new Date().toISOString()
        });
        console.log('다음으로 버튼 클릭 - null 처리됨');
    } else {
        console.log('이미 해당 시나리오의 이유가 저장되어 있음 - 중복 저장 방지');
    }
    
    // 로컬 스토리지에 사용자 데이터 저장
    const userData = {
        choices: userChoices,
        reasons: userReasons,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem('userTestData', JSON.stringify(userData));
    console.log('💾 사용자 데이터 저장 완료 (null 포함):', userData);
    
    // 다음 시나리오로 진행
    currentScenario++;
    updateScenario();
    
    // UI 초기화
    resetUI();
}

// 텍스트 정규화 함수 (띄어쓰기 차이로 인한 점수 변동 방지)
function normalizeText(text) {
    if (!text) return text;
    
    return text
        .trim()                    // 앞뒤 공백 제거
        .replace(/\s+/g, ' ')      // 연속 공백을 하나로 축소
        .replace(/\s*([,.!?])\s*/g, '$1'); // 구두점 주변 공백 정리
}

// 욕설 및 비속어 검증 (개선안 v1.2 + Whitelist 오탐 방지)
function containsInappropriateLanguage(text) {
    // 정규식 패턴: 단어 경계 기반 탐지로 일반 단어 내부 부분 일치 오탐 방지
    // 플래그: i (대소문자 무시), u (유니코드)
    const profanityPattern = /(?<![가-힣A-Za-z])(씨\s발|시\s발|ㅆ\sㅂ|병\s신|ㅂ\sㅅ|개\s같|좆|존\s*나|fuck|shit|bitch|asshole)(?![가-힣A-Za-z])/iu;
    
    // Whitelist (오탐 방지용 일반 단어들)
    const whitelistWords = ["현황","도출","개선","파악","결정","출시","분석","검토","측정","도전","기능","제품","서비스","사용자","시장","점유"];
    
    // 1) reason_original에 대해 위 정규식으로 1차 검사
    const hasProfanityMatch = profanityPattern.test(text);
    
    if (!hasProfanityMatch) {
        return false; // 금칙어 패턴이 없으면 통과
    }
    
    // 2) 매칭되면 Whitelist 단어 포함 여부 확인
    const hasWhitelistWord = whitelistWords.some(word => text.includes(word));
    
    if (hasWhitelistWord) {
        console.log('🛡️ PROFANITY Whitelist 적용: 일반 단어 포함으로 오탐 방지');
        return false; // 오탐 가능성 → PROFANITY 미적용(통과)
    }
    
    // 포함 X → PROFANITY 적용(reject)
    console.log('🚫 PROFANITY 탐지: 금칙어 패턴 발견');
    return true;
}

// 유의미도 점수 계산 (강화형 하이브리드 채점 시스템) - 새로운 LLM-Judge 형식
async function calculateMeaningfulnessScore(text, scenario, selectedOption) {
    const questionId = `Q${scenario}`;
    
    try {
        // 전체 점수 계산 시간 측정 시작
        const totalScoringStartTime = performance.now();
        console.log(`🚀 전체 점수 계산 시작 - 문항: ${questionId}, 선택지: ${selectedOption}`);
        
        // 1. LLM-Judge 방식으로 의미 기반 점수 계산 (핵심)
        const judgeResult = await calculateSemanticModel(text, questionId, selectedOption);
        const semanticModel = judgeResult.semantic_relevance;
        const judgeConfidence = judgeResult.confidence;
        const judgeRationale = judgeResult.rationale;
        
        // 2. 규칙 기반 보정값 계산 (rule_adjustment)
        const ruleAdjustment = calculateRuleAdjustment(text, scenario, selectedOption);
        
        // 3. LLM 중심 하이브리드 결합: LLM 80% + 규칙 보정 20%
        const semanticRelevance = Math.max(0, Math.min(10, (semanticModel * 0.8) + (ruleAdjustment * 0.2)));
        
        // 4. 구체성과 표현품질은 기존 로직 유지
        const specificity = calculateSpecificity(text, scenario, selectedOption);
        const expressionQuality = calculateExpressionQuality(text, scenario, selectedOption);
        
        // 의미-형식 연동 보정 (semantic safeguard)
        let adjustedSpecificity = specificity;
        let adjustedExpressionQuality = expressionQuality;
        
        if (semanticRelevance >= 7.0) {
            adjustedSpecificity = Math.max(specificity, 6.0);         // 구체성 하한 보정
            adjustedExpressionQuality = Math.max(expressionQuality, 5.5); // 표현품질 최소 보정
            console.log(`🛡️ 의미-형식 연동 보정 적용: semantic_relevance=${semanticRelevance.toFixed(2)}`);
            console.log(`  - 구체성: ${specificity.toFixed(2)} → ${adjustedSpecificity.toFixed(2)}`);
            console.log(`  - 표현품질: ${expressionQuality.toFixed(2)} → ${adjustedExpressionQuality.toFixed(2)}`);
        }
        
        // 5. 최종 가중합 계산 (보정된 값 사용)
        const weightedTotal = (semanticRelevance * 0.6) + (adjustedSpecificity * 0.25) + (adjustedExpressionQuality * 0.15);
        
        // 6. 최종 판정 (PASS 기준: 5.5)
        const decision = weightedTotal < 5.5 ? 'reject' : 'pass';
        
        // 전체 점수 계산 시간 측정 종료
        const totalScoringEndTime = performance.now();
        const totalScoringDuration = totalScoringEndTime - totalScoringStartTime;
        
        console.log(`🎯 하이브리드 채점 결과:`);
        console.log(`  - semantic_model: ${semanticModel.toFixed(2)} (80%)`);
        console.log(`  - rule_adjustment: ${ruleAdjustment.toFixed(2)} (20%)`);
        console.log(`  - 결합된 semantic_relevance: ${semanticRelevance.toFixed(2)}`);
        console.log(`  - specificity: ${adjustedSpecificity.toFixed(2)}`);
        console.log(`  - expression_quality: ${adjustedExpressionQuality.toFixed(2)}`);
        console.log(`  - weighted_total: ${weightedTotal.toFixed(2)}`);
        console.log(`  - decision: ${decision}`);
        console.log(`  - judge_confidence: ${judgeConfidence.toFixed(2)}`);
        console.log(`  - judge_rationale: "${judgeRationale}"`);
        console.log(`⏱️ 전체 점수 계산 완료 - 총 소요시간: ${totalScoringDuration.toFixed(2)}ms (${(totalScoringDuration/1000).toFixed(2)}초)`);
        
        return {
            weightedTotal,
            decision,
            scores: {
                semantic_model: semanticModel,
                rule_adjustment: ruleAdjustment,
                semantic_relevance: semanticRelevance,
                specificity: adjustedSpecificity,
                expression_quality: adjustedExpressionQuality,
                weighted_total: weightedTotal
            },
            judge_confidence: judgeConfidence,
            judge_rationale: judgeRationale
        };
        
    } catch (error) {
        console.error('하이브리드 채점 오류:', error);
        
        // 오류 시 기존 방식으로 폴백
        console.log('⚠️ 폴백: 기존 키워드 기반 채점 사용');
        const semanticRelevance = calculateRuleAdjustment(text, scenario, selectedOption) + 3.0; // 기본값 3.0 추가
        const specificity = calculateSpecificity(text, scenario, selectedOption);
        const expressionQuality = calculateExpressionQuality(text, scenario, selectedOption);
        
        // 의미-형식 연동 보정 (폴백 모드에서도 적용)
        let adjustedSpecificity = specificity;
        let adjustedExpressionQuality = expressionQuality;
        
        if (semanticRelevance >= 7.0) {
            adjustedSpecificity = Math.max(specificity, 6.0);
            adjustedExpressionQuality = Math.max(expressionQuality, 5.5);
            console.log(`🛡️ 폴백 모드 의미-형식 연동 보정 적용: semantic_relevance=${semanticRelevance.toFixed(2)}`);
        }
        
        const weightedTotal = (semanticRelevance * 0.6) + (adjustedSpecificity * 0.25) + (adjustedExpressionQuality * 0.15);
        const decision = weightedTotal < 5.5 ? 'reject' : 'pass';
        
        console.log(`유의미도 점수 (폴백): 의미일치도(${semanticRelevance.toFixed(2)}) + 구체성(${specificity.toFixed(2)}) + 표현품질(${expressionQuality.toFixed(2)}) = ${weightedTotal.toFixed(2)}`);
        
        return {
            weightedTotal,
            decision,
            scores: {
                semantic_model: 4.0,
                rule_adjustment: semanticRelevance - 3.0,
                semantic_relevance: semanticRelevance,
                specificity: adjustedSpecificity,
                expression_quality: adjustedExpressionQuality,
                weighted_total: weightedTotal
            },
            judge_confidence: 0.3,
            judge_rationale: "폴백 모드"
        };
    }
}

// 의도 프리셋(Intent Presets) 정의 - 상세한 문장 형식
const INTENT_PRESETS = {
    "Q1": {
      "A": {
        "target": [
          // 기존 + 확장 (전문형/일상형/밀크T)
          "직접 사용하거나 체험을 통해 문제를 탐색한다",
          "사용자 입장에서 제품을 경험하고 불편 지점을 찾는다",
          "현장 중심 관찰을 통해 인사이트를 얻는다",
          "직접 만져보며 개선 아이디어를 도출한다",
          "실사용 경험을 바탕으로 감각적으로 판단한다",
          "고객/유저 입장에서 흐름을 재현하고 느낀다",
          "고객 입장에서 한번 써볼게요",
          "직접 해보면 뭐가 불편한지 알 것 같아요",
          "제가 써보면서 감을 잡아볼게요",
          "일단 써보고 느낌을 정리하겠습니다",
          "유저 입장에서 생각해볼게요",
          // 확장-전문형
          "실사용 흐름을 따라가며 마찰 구간을 관찰한다",
          "학생/학부모 실제 계정으로 온보딩부터 결제까지 체험한다",
          "AI 추천 클릭 전후 UX를 직접 경험하고 불편을 기록한다",
          "학습 경로와 과제 제출 플로우를 손으로 재현한다",
          "오답노트·즐겨찾기 기능을 만져보며 개선점 메모한다",
          // 확장-일상형
          "내가 직접 써보면 뭐가 걸리는지 빨리 느껴져요",
          "학생 입장으로 로그인해서 처음부터 쭉 써볼게요",
          "결제까지 한번 밟아보면 문제 보일 듯해요",
          "유저처럼 눌러보면서 불편을 찾을게요",
          "한번 체험해봐야 할 것 같아요",
          "직접 해봐야 답이 나올 것 같아요",
          "제가 써보고 바로 알려드릴게요",
          "한번 만져보면 바로 감 올 거예요",
          "써봐야 진짜 불편한 게 뭔지 보여요",
          "직접 눌러보면 뭐가 이상한지 바로 나와요",
          "그냥 한번 돌려봐야 알죠",
          "실제로 돌려봐야 진짜 문제점이 보여요",
          "직접 써보면 답 나옵니다",
          "이건 써봐야 문제 보입니다",
          "눈으로 보기엔 괜찮은데 실제로 써보면 다르더라고요",
          "직접 해보면 이상하게 느껴지는 포인트가 있을 거예요",
          "유저처럼 써봐야 개선 포인트가 보여요",
          "앱을 켜서 실제로 한번 해볼게요",
          "실사용자 입장에서 테스트해봐야 해요",
          "눈으로 보는 거랑 써보는 건 달라요",
          "체험 없이는 개선 포인트가 안 보여요",
          "직접 써보면 감이 와요",
          "사용자처럼 눌러보면서 감 잡아볼게요",
          "그냥 써보면 다 느껴집니다",
          "진짜 유저처럼 써봐야 문제 보여요",
          "직접 써봐야 감 잡힙니다",
          "일단 체험해보죠, 말로는 감이 안 와요",
          "직접 로그인해서 해볼게요",
          "내가 유저라 생각하고 써볼게요",
          "실제로 써보면 답이 나와요",
          "직접 경험해봐야 진짜 보이는 게 있어요",
          // 확장-일상형(추가)
          "일단 손에 익혀봐야 보여요",
          "이건 손으로 눌러봐야 감 잡혀요",
          "처음 써보는 사람처럼 쭉 타보겠습니다",
          "새로 설치해서 클린 상태로 테스트해볼게요",
          "처음 유입 동선부터 다시 걸어보죠",
          "결제 직전까지 쭉 타보면 걸리는 데 나올 듯요",
          "실제로 퀴즈 풀어보면 감 오죠",
          "해설까지 끝까지 가봐야 진짜 느낌 알아요",
          "회원가입부터 링크 타고 들어가볼게요",
          "푸시 받고 진입하는 흐름 그대로 재현해볼게요",
          "실제 디바이스로 해볼게요, 에뮬레이터 말고",
          "네트워크 느린 환경도 직접 돌려봐야 해요",
          "손에 땀나게 써봐야 문제 나옵니다",
          "처음 보는 사람처럼 막혀보는 게 중요해요",
          "일단 써보고 화면 녹화로 공유할게요",
          "실사례로 과제 하나 만들어서 돌려보죠",
          "터치 수가 많은지, 반응이 느린지 체감해볼게요",
          "UI가 어색한지 손이 말해줄 거예요",
          "사용자의 멈칫 포인트를 직접 느껴보죠",
          "한번 써보면 어디가 거슬리는지 딱 보여요",
          // 확장-일상형(추가2)
          "처음 보는 눈으로 훑어봐야 걸리는 지점이 보여요",
          "튜토리얼부터 따라가 보면서 막히는 곳 체크할게요",
          "실제로 써보면 버튼 위치가 편한지 바로 느껴집니다",
          "한 손 사용으로도 되는지 직접 해볼게요",
          "설정 초기화해 놓고 새 유저처럼 써보겠습니다",
          "중간에 멈칫하는 순간을 영상으로 남겨둘게요",
          "처음 접속해서 홈 화면 인상부터 체감해볼게요",
          "오탈자나 작은 불편은 손으로 써봐야 보입니다",
          "알림 눌러서 바로 들어오는 동선도 확인해볼게요",
          "화면 전환이 자연스러운지 손맛으로 볼게요",
          "회원가입에서 놓치는 필드가 있는지 직접 겪어볼게요",
          "실제 과금 직전까지 눌러보며 부담감이 있는지 느껴볼게요",
          "탭 전환할 때 끊김이 있는지 손으로 체크할게요",
          "사용자가 멈추는 지점은 체감이 제일 정확합니다",
          "첫 느낌이 안 좋으면 이탈하니 그 감을 확인해볼게요",
          "툴팁·가이드가 과한지 부족한지 써봐야 알아요",
          "문구가 어려운지 쉬운지 직접 읽어보면 감이 와요",
          "손가락 동선이 꼬이지 않는지 테스트해볼게요",
          "한 번 훑고, 두 번째에 자세히 눌러보겠습니다",
          "아이처럼 써보고, 학부모처럼도 다시 체험해볼게요",
          "다른 기기에서도 같은 느낌인지 비교 체험해볼게요",
          "밝기 낮추고도 보이는지 실제로 확인해볼게요",
          "처음 유저에게 과제가 너무 무거운지 몸으로 느껴볼게요",
          "검색 없이도 길을 찾을 수 있는지 직접 걸어보겠습니다",
          "뒤로가기가 자연스러운지 손으로 익혀볼게요",
          "터치 반응이 빠른지 느린지 체감이 중요합니다",
          "새 알림이 방해되는지 직접 써보며 보겠습니다",
          "문제 풀이 흐름이 끊기지 않는지 끝까지 체험해볼게요",
          "직접 해보면 ‘여기서 포기하겠다’ 싶은 순간이 나옵니다",
          "써보면서 바로바로 메모해 공유하겠습니다"
        ]
      },
      "B": {
        "target": [
          "데이터나 로그를 기반으로 문제의 원인을 분석한다",
          "수치 지표를 비교하여 이상 패턴을 찾는다",
          "정량적 근거를 통해 개선 방향을 도출한다",
          "이탈 단계나 퍼널 전환율을 분석한다",
          "지표 변화를 모니터링해 가설을 검증한다",
          "이탈이 생긴 부분에 대해 수정하면 최소한의 비용으로 문제를 해결할 수 있다",
          // 확장-전문형
          "퍼널 전환율로 이탈 구간을 식별한다",
          "Amplitude/GA 이벤트 로그로 비정상 패턴을 확인한다",
          "코호트/잔존 분석으로 급감 원인을 찾는다",
          "DAU/MAU 대비 세션당 학습시간 변화를 검토한다",
          "결제 퍼널과 오류 로그로 실패율을 추적한다",
          "진입단계에서 흐름에따라 분석이 필요해서",
          // 확장-일상형
          "지표로 어디서 떨어지는지 먼저 볼게요",
          "일단 수치부터 확인해볼게요",
          "로그 찍히는 구간부터 보겠습니다",
          "대시보드로 추세를 먼저 파악하겠습니다",
          "숫자부터 보는 게 빠를 것 같아요",
          "데이터는 거짓말을 하지 않는다",
          "어느 부분에서 이탈이 생겼는지 확인하면 보완할 부분을 눈으로 확인할 수 있다",
          // 확장-밀크T 맥락형
          "학습 추천 진입률/클릭률을 먼저 확인합니다",
          "과제 시작 전 이탈 비중이 급증했는지 봅니다",
          "결제 실패 코드별 비중 변화를 확인합니다",
          "학부모 모드 전환 퍼널을 비교합니다",
          "신규 학생 온보딩 완료율을 시점별로 추적합니다",
          // 확장-일상형(추가)
          "일단 숫자부터 봐야죠",
          "로그 보면 바로 나올 거예요",
          "데이터로 찍히는 구간부터 체크해볼게요",
          "지표 보면서 어디서 떨어졌는지 파악하죠",
          "일단 대시보드 켜볼게요",
          "데이터를 보면 감보다는 확실하죠",
          "감으로는 모르겠고, 숫자부터 확인해야죠",
          "로그 분석이 제일 빠르죠",
          "데이터로 비교해보면 답 나올 듯해요",
          "수치로 보면 명확하게 보일 거예요",
          "숫자부터 확인해보죠, 감으로 하면 틀릴 수도 있어요",
          "퍼널부터 한번 그려보죠",
          "데이터 기반으로 접근해야 실수 안 해요",
          "추세 그래프 보면 감 잡히죠",
          "일단 클릭률부터 확인합시다",
          "로그로 어디서 끊기는지 확인해볼게요",
          "감보다 수치로 판단하는 게 정확하죠",
          "분석 툴 켜서 바로 확인해볼게요",
          "이건 데이터가 말해줍니다",
          "일단 통계부터 보죠",
          "지표 먼저 확인하고 얘기합시다",
          "로그 찍힌 구간 보면 바로 보여요",
          "수치로 보면 확실히 이해돼요",
          "데이터 보면 답 나올 듯요",
          "이건 감이 아니라 수치로 가야 해요",
          "세그먼트 나눠서 보면 원인 더 잘 보여요",
          "전/후 비교로 날짜 효과도 확인합시다",
          "특정 디바이스/OS에서 튀는지 보죠",
          "버전별로 비교하면 감 잡힐 거예요",
          "이벤트 찍힌 타임라인 먼저 볼게요",
          "주요 지표 상관관계 한번 보죠",
          // 확장-일상형(추가2)
          "최근 업데이트 전후로 그래프가 달라졌는지부터 볼게요",
          "갑자기 꺾인 날이 있는지 날짜부터 찍어보겠습니다",
          "유입은 멀쩡한데 시작률만 빠졌는지 확인해볼게요",
          "특정 과목에서만 떨어졌는지도 분리해서 보겠습니다",
          "앱/웹 채널별로 흐름이 다른지 나눠볼게요",
          "신규랑 기존 유저를 나눠서 비교하면 보일 거예요",
          "주말이랑 평일 패턴 차이부터 확인할게요",
          "광고가 바뀐 시점과 겹치는지도 보겠습니다",
          "오류 알림이 늘었는지 로그 개수도 같이 볼게요",
          "결제 시도 대비 성공 비율이 변했는지 확인하겠습니다",
          "페이지 체류가 줄었는지 평균 시간도 볼게요",
          "앱 크래시가 늘었는지 리포트 먼저 보겠습니다",
          "유저가 많이 눌러본 버튼이 바뀌었는지 클릭맵 확인할게요",
          "검색 없이 진입하는 비중이 줄었는지 체크하겠습니다",
          "푸시 열람률이 떨어진 건 아닌지 살펴볼게요",
          "알림에서 들어와서 바로 나가는 비율도 보겠습니다",
          "탐색 시간이 길어졌는지, 짧아졌는지 비교할게요",
          "특정 OS 버전에서만 급감했는지도 보겠습니다",
          "최신 앱 버전으로 올린 뒤 변화가 있었는지 볼게요",
          "코호트별 첫 주/둘째 주 잔존 비교하겠습니다",
          "추천 진입 대비 학습 시작이 줄었는지 보겠습니다",
          "퀴즈 완료율이 갑자기 낮아졌는지도 체크할게요",
          "로그가 비어 있는 구간이 있는지 누락 여부 보겠습니다",
          "유저 문의량이 늘었는지도 참고하겠습니다",
          "시간대별로 이탈이 몰리는 구간이 있는지 보겠습니다",
          "유입 채널 믹스가 바뀌었는지부터 보죠",
          "버튼 위치 변경 전후 클릭률 비교하겠습니다",
          "로드 시간이 늘었는지 응답 속도도 확인할게요",
          "대시보드 필터를 잘라보면 원인이 좁혀질 거예요",
          "숫자로 원인 좁히고, 필요하면 현장 검증 붙이겠습니다"
        ]
      }
    },
  
    "Q2": {
      "A": {
        "target": [
          "속도와 시장 선점을 중시한다",
          "경쟁사보다 빠르게 출시하는 것을 목표로 한다",
          "완벽하지 않아도 먼저 내어보고 개선한다",
          "빠른 학습 루프와 즉시 행동을 선호한다",
          "MVP나 최소 기능으로 빠르게 시장 반응을 본다",
          "시장 점유나 선점 이익을 전략적으로 고려한다",
          "경쟁사보다 먼저 내야 해요",
          "완벽하진 않아도 빨리 내는 게 중요하죠",
          "일단 만들어서 반응 보자",
          "시간 없으니까 빠르게 진행해야죠",
          "먼저 시작하는 게 유리해요",
          // 확장-전문형
          "MVP로 소프트런치하고 지표 보며 개선한다",
          "first-to-market 우위를 확보한다",
          "실험 배포로 빠른 학습 루프를 돌린다",
          "베타 트랙으로 조기 피드백을 수집한다",
          "시장 반응을 먼저 검증하고 스케일한다",
          // 확장-일상형
          "빨리 내보고 반응부터 보죠",
          "작게라도 빨리 돌려보겠습니다",
          "일단 내고 고치면 됩니다",
          "먼저 시작해봐야 알죠",
          "시장을 먼저 잡아야 해요",
          // 확장-밀크T 맥락형
          "AI 추천은 최소 추천 카드로 먼저 노출합니다",
          "학습 진입 배너만 우선 배포해 클릭률을 봅니다",
          "학부모 알림 연동은 1차에 코어만 붙입니다",
          "추천 정확도는 후속 릴리즈에서 단계적으로 올립니다",
          "스토어 설명·스크린샷은 빠르게 선공개합니다",
          // 확장-일상형(추가)
          "일단 만들어서 돌려보죠",
          "빨리 나가야 경쟁사보다 앞섭니다",
          "작게라도 빨리 해보는 게 낫죠",
          "지금 내고 나중에 고쳐도 돼요",
          "테스트라도 빨리 돌려보는 게 좋아요",
          "시간이 생명입니다",
          "속도가 곧 경쟁력이에요",
          "완벽하게 만들다 늦는 게 더 위험하죠",
          "일단 반응부터 봐요",
          "베타라도 내봅시다",
          "실제로 내봐야 문제도 보여요",
          "처음엔 완벽할 필요 없어요, 내고 고치면 되죠",
          "빠른 실행이 제일 중요하죠",
          "일단 돌려야 피드백도 받죠",
          "빨리 시도해봐야 배우죠",
          "완벽은 나중 문제, 일단 나갑시다",
          "시장은 기다려주지 않아요",
          "테스트 배포라도 해보죠",
          "경쟁사보다 먼저 가야 의미 있어요",
          "빨리 내야 흐름 안 끊겨요",
          "시간 싸움이에요 지금",
          "빨리 돌려서 데이터 얻자",
          "MVP라도 나가야 반응 볼 수 있죠",
          "피드백은 내야 들어옵니다",
          "점진적으로 키우면 됩니다, 일단 스타트",
          "코어만 묶어서 먼저 출발하죠",
          "기능은 얇게, 속도는 빠르게",
          "고객에게 빨리 보여주고 배웁시다",
          // 확장-일상형(추가2)
          "먼저 깃발 꽂아야 뒤에 정리도 수월합니다",
          "작게 내고 자주 고치는 게 더 안전해요",
          "완벽주의 버리면 속도가 납니다",
          "일단 굴려보고 문제는 달리면서 고치죠",
          "베타로 반응만 확인해도 큰 수확이에요",
          "지금 타이밍 놓치면 의미가 줄어듭니다",
          "핵심 한 줄만 먼저 보여줍시다",
          "첫 단추만 끼우면 나머진 속도 붙어요",
          "기다리다 기회를 놓치느니 시작합시다",
          "경량 버전으로 빠르게 시장 감 잡아요",
          "선점하면 피드백도 먼저 받습니다",
          "작은 승리를 빨리 만들고 키우죠",
          "리스크는 얇게, 학습은 빠르게 가져가요",
          "처음엔 80점으로, 다음에 90점 만들죠",
          "지금 달리면 따라오기 힘들어요",
          "문제는 나가야 드러납니다",
          "마일스톤을 잘게 쪼개서 속도를 냅시다",
          "초기 경험만 매끈하면 됩니다, 나머진 후속으로",
          "최소 기능만 확보하고 바로 출시합시다",
          "선 공개로 기대감을 먼저 만듭시다",
          "피처 토글로 위험은 낮추고 속도는 높이죠",
          "스냅샷 수준으로라도 유저 손에 빨리",
          "초기 타깃만 콕 찍고 시작합시다",
          "작게 이겨보고 크게 확장하면 돼요",
          "‘지금’이 가장 빠른 때입니다",
          "오늘 나가고 내일 배우는 흐름이 좋아요",
          "경쟁사는 우리 기다려주지 않아요",
          "시장 반응이 기획보다 정확합니다",
          "빨리 실패해 빨리 배우는 게 이득이에요",
          "달리면서 조정하는 게 현실적입니다"
        ]
      },
      "B": {
        "target": [
          "충분한 검증과 테스트를 거쳐 출시한다",
          "브랜드 이미지와 품질을 최우선으로 한다",
          "리스크를 줄이고 안정적인 결과를 추구한다",
          "신중한 검토와 QA를 통해 완성도를 높인다",
          "빠른 출시보다 품질 확보를 더 중요하게 본다",
          // 확장-전문형
          "QA/회귀 테스트를 충분히 거친다",
          "브랜드 이미지와 평판 하락 리스크를 관리한다",
          "재출시·롤백 비용을 줄이도록 안정성을 확보한다",
          "오류/장애 가능성을 낮추고 CS 폭주를 방지한다",
          "스토어 평점과 리뷰 악화를 막는다",
          // 확장-일상형
          "기업 이미지 지키려면 검증을 먼저 합시다",
          "재출시하면 신뢰가 떨어져요, 신중히 가죠",
          "품질이 담보되어야 합니다",
          "서두르다 크게 데일 수 있어요",
          "완성도부터 챙기겠습니다",
          // 확장-밀크T 맥락형
          "학부모 민원/평판 리스크를 줄이겠습니다",
          "추천 오류로 잘못된 과제를 주는 일은 막아야 합니다",
          "결제/로그인 실패는 반드시 선차단합니다",
          "학습 기록 유실 리스크를 최소화합니다",
          "AI 추천 근거 노출 품질을 먼저 맞춥니다",
          // 확장-일상형(추가)
          "급하게 내면 사고 납니다",
          "완성도 떨어지면 신뢰도 떨어져요",
          "천천히 가도 확실하게 가는 게 좋아요",
          "버그 많으면 오히려 손해예요",
          "품질부터 챙기죠, 시간보다 중요합니다",
          "문제 생기면 고치는 데 더 오래 걸려요",
          "급하게 내서 욕먹을 바엔 늦게라도 완성도 있게",
          "CS 터지면 감당 안 돼요",
          "테스트 안 하면 후회할 겁니다",
          "버그 잡는 게 더 우선이에요",
          "완성도 낮으면 평점 떨어져요",
          "서두르다 망치느니 검증부터 합시다",
          "충분히 점검하고 내야 해요",
          "리뷰 한번 나빠지면 회복 어렵죠",
          "불안정하게 내면 오히려 더 늦어요",
          "테스트부터 돌립시다",
          "안정성 확보가 먼저예요",
          "급하게 내는 건 리스크예요",
          "품질 무너지면 다 무너집니다",
          "시간보다 신뢰가 중요하죠",
          "QA 통과 못 하면 못 냅니다",
          "이건 완성도 확보가 최우선이에요",
          "브랜드는 한 번 무너지면 끝입니다",
          "사용자 신뢰를 먼저 지켜야 해요",
          "에지 케이스도 충분히 밟아봅시다",
          // 확장-일상형(추가2)
          "한 번 삐끗하면 신뢰 회복이 더 어렵습니다",
          "느리더라도 제대로 가는 게 맞아요",
          "오늘 늦는 게 내일 빠른 겁니다",
          "초반 품질이 평점을 좌우합니다",
          "장애 한 번이면 마케팅이 다 말라요",
          "고장 없는 상태로 내는 게 최선입니다",
          "검증은 비용이 아니라 보험이에요",
          "사용자에게 민감한 화면은 더 꼼꼼히 보죠",
          "작은 버그도 체감은 크게 다가옵니다",
          "리뷰는 쌓이기 어렵고 무너지긴 쉬워요",
          "CS 줄이는 게 최고의 성장입니다",
          "완성도는 결국 비용을 절약해요",
          "첫인상은 두 번 만들기 힘듭니다",
          "테스트 케이스 없이 내면 운에 맡기는 거예요",
          "문제 없다는 확신이 들 때 내는 게 맞습니다",
          "롤백은 마지막 선택이어야 합니다",
          "브랜드는 시간이 아닌 행동으로 쌓입니다",
          "한 번에 가지 말고 점검하면서 가요",
          "불확실하면 멈추고 확인하는 게 정답입니다",
          "기대보다 안정이 먼저입니다",
          "유저의 시간을 빼앗지 말아야 합니다",
          "장비부터 상태 점검하고 출발합시다",
          "문서로 남겨야 실수가 줄어요",
          "테스트 통과는 최저선, 그 위로 올립시다",
          "문제 재현이 되지 않으면 해결도 어렵습니다",
          "수정보다 예방이 싸게 먹힙니다",
          "급한 마음이 큰 실수를 부릅니다",
          "안정은 습관에서 옵니다",
          "품질은 결국 팀의 약속입니다",
          "천천히 가도 확실히 갑시다"
        ]
      }
    },
  
    "Q3": {
      "A": {
        "target": [
          "일정을 고려하여 우선순위를 조정한다",
          "현실적인 계획과 대안을 제시한다",
          "영향도와 난이도를 비교해 결정한다",
          "효율적으로 리소스를 배분한다",
          "문제 상황을 구조적으로 정리한다",
          "중요한 것부터 처리할게요",
          "할 수 있는 것부터 하겠습니다",
          "일정 안에 가능한 것만 우선하죠",
          "급한 순서대로 하겠습니다",
          "우선순위대로 정리할게요",
          "목표를 근거로 사람들을 설득한다",
          // 확장-전문형
          "임팩트·난이도 매트릭스로 우선순위를 정한다",
          "MoSCoW로 스코프를 분류한다",
          "크리티컬 패스와 버퍼를 재설정한다",
          "병목을 해소하는 순서로 할당한다",
          "마일스톤 기준으로 대안을 정리한다",
          // 확장-일상형
          "일정 안에서 가능한 것부터 하죠",
          "영향 큰 것부터 먼저 처리하겠습니다",
          "현실적으로 가능한 대안부터 묶겠습니다",
          "지금 가능한 걸 먼저 하겠습니다",
          "당장 할 수 있는 것부터 하죠",
          // 확장-밀크T 맥락형
          "추천 카드 노출/로그인/결제 순으로 우선순위화합니다",
          "학생 진입-퀴즈-해설 흐름부터 안정화합니다",
          "학부모 알림은 다음 스프린트로 이관합니다",
          "디자인 모션은 최소화하고 핵심 UI 먼저 진행합니다",
          "분석 이벤트 스키마 정의를 선행합니다",
          // 확장-일상형(추가)
          "지금 당장 할 수 있는 일부터 하죠",
          "일단 급한 것부터 처리합시다",
          "중요한 순서대로 정리할게요",
          "지금 리소스 고려해서 정리하겠습니다",
          "무리하지 말고 우선순위대로 갑시다",
          "할 수 있는 거부터 끝내야 해요",
          "효율적으로 나눠서 합시다",
          "먼저 해야 할 일부터 체크하죠",
          "일정 안에서 가능한 걸 먼저 하겠습니다",
          "급한 것, 중요한 것 순서로 가요",
          "시간 대비 효율 생각해야죠",
          "무리하게 다 하려다 망쳐요",
          "핵심부터 처리합시다",
          "일단 급한 불부터 꺼야죠",
          "지금 중요한 게 뭔지 다시 정리하죠",
          "순서만 잘 잡아도 반은 갑니다",
          "효율적으로 배분해봅시다",
          "일정 고려해서 조정할게요",
          "지금 리소스로 가능한 범위부터 하죠",
          "중요도 기준으로 나눠보죠",
          "지금 병목만 풀어도 속도 나옵니다",
          "해야 할 것/미뤄도 되는 것 나눠봅시다",
          "크게 가기보다 잘라서 가죠",
          "빨리 끝낼 수 있는 것부터 캐치업합시다",
          // 확장-일상형(추가2)
          "큰 일부터 작게 쪼개서 순서대로 가요",
          "한 번에 다 하려 말고 먼저 길부터 내죠",
          "오늘 처리, 이번 주 처리로 나눠봅시다",
          "영향 큰 것 한두 개만 잡고 확실히 끝내요",
          "지금 병목만 뚫어도 전체가 빨라집니다",
          "못 하는 건 과감히 다음으로 미룹시다",
          "필수/선택 구분해서 리스트업하죠",
          "데드라인 기준으로 뒤에서부터 정리해볼게요",
          "겹치는 일은 묶어서 처리하면 빨라요",
          "중복되는 건 과감히 빼겠습니다",
          "먼저 결과가 나오는 걸로 자신감부터 올리죠",
          "한 번에 두 마리 토끼 말고 하나씩",
          "회의 줄이고 실행 시간 늘려봅시다",
          "우선순위는 매일 가볍게 재정렬해요",
          "지금 해야 할 이유가 없는 건 빼겠습니다",
          "마감일 보면서 할당을 다시 나눌게요",
          "예상 공수 긴 건 쪼개서 배치하죠",
          "기다리는 일은 백그라운드로 돌려둡시다",
          "의존성 높은 건 먼저 풀고 가요",
          "결정 미룰수록 비용이 커지니 지금 정리하죠",
          "완벽보다 제때 마치는 걸 우선합시다",
          "손대면 바로 끝나는 건 오늘 끝내요",
          "힘든 일은 아침에, 단순한 건 오후로",
          "진행 막히면 바로 도움 요청하는 걸로",
          "체크리스트 만들어 지우면서 가겠습니다",
          "일단 기준 잡고 나머지는 따라가게 하죠",
          "필요 없는 승인은 단계 줄이겠습니다",
          "문서 한 장으로 정리해 공유하겠습니다",
          "주간 목표 세 개만 꽉 채워봅시다",
          "마감 전 버퍼 살려두고 움직여요"
        ]
      },
      "B": {
        "target": [
          "팀원 간 공감과 대화를 중시한다",
          "서로의 입장을 이해하고 조율한다",
          "협업과 합의를 통해 문제를 해결한다",
          "감정적 배려를 통해 갈등을 완화한다",
          "팀워크 중심으로 의사결정을 이끈다",
          // 확장-전문형
          "제약과 목표를 공유하고 트레이드오프를 합의한다",
          "디자인/개발의 우선 요구를 듣고 공통안을 찾는다",
          "감정적 격화를 낮추고 논점만 남긴다",
          "비동기 문서로 쟁점을 정리해 합의한다",
          "파킹랏을 두고 이견을 분리한다",
          // 확장-일상형
          "서로 얘기 들어보면 답이 나올 거예요",
          "입장부터 맞추고 이야기하죠",
          "일단 대화부터 해보죠",
          "먼저 공감대부터 만들게요",
          "같이 조율해보겠습니다",
          // 확장-밀크T 맥락형
          "애니메이션 강도/빈도를 낮추는 절충안을 찾습니다",
          "개발 난이도 높은 효과는 다음 릴리즈로 분리합니다",
          "과제 시작 성능 영향은 개발 의견을 반영합니다",
          "학습 집중 저해 요소는 디자인과 재조정합니다",
          "가이드라인을 합의해 재작업 비용을 줄입니다",
          // 확장-일상형(추가)
          "양쪽 이야기를 다 들어보고 중간에서 맞춰봅시다",
          "서로 입장 이해부터 하고 시작하죠",
          "감정은 잠깐 내려놓고 논점만 정리해볼게요",
          "최소한의 공통분모부터 찾아봅시다",
          "필수/선호를 구분해 합의 지점을 만들죠",
          "회의 톤 낮추고 차분하게 다시 이야기해요",
          "한 번만 더 상대 입장에서 생각해보자고 제안할게요",
          "비동기로 쟁점을 정리해서 불필요한 감정 소모 줄이죠",
          "맞교환 가능한 항목부터 바꿔봅시다",
          "오늘은 결론 80%까지만, 나머지는 파킹랏으로",
          "의견 충돌이 아니라 목표가 같은지 먼저 확인하죠",
          "서로 우선순위를 공유하면 해법 보일 거예요",
          "성능/효과 중간값으로 타협점 만들어볼게요",
          "지금 당장 필요한 것만 합의하고 나머진 분리하죠",
          "합의된 기준 생기면 같은 논쟁 반복 안 해요",
          "일단 웃고 시작합시다, 분위기부터 풀어요",
          "우리 팀 같은 편이라는 걸 다시 상기시키죠",
          // 확장-일상형(추가2)
          "먼저 듣고, 나중에 말하겠습니다",
          "상대가 중요하게 보는 포인트부터 인정할게요",
          "말 끊지 말고 끝까지 듣는 걸로 합시다",
          "주장보다 사실부터 맞춰보죠",
          "같은 말 반복은 줄이고 요점으로 가요",
          "오늘 정리, 내일 재확인으로 부담 줄이겠습니다",
          "갈등은 탓보다 해결에 초점을 맞출게요",
          "나의 ‘원함’과 팀의 ‘필요’를 구분해봅시다",
          "서로가 내는 비용을 숫자 대신 감정으로도 보죠",
          "결정은 공개적으로, 피드백은 따로 드릴게요",
          "반대 의견에도 고개 끄덕임부터 하겠습니다",
          "합의가 안 되면 실험으로 결정하죠",
          "필요하면 타임아웃 갖고 차분히 다시",
          "다음 회차에 반드시 팔로업하겠습니다",
          "‘왜’보단 ‘어떻게’를 더 묻겠습니다",
          "칭찬 한 줄, 개선 한 줄로 균형 맞출게요",
          "회의 끝나고 핵심만 한 장으로 남기겠습니다",
          "말보다 시안·시연으로 확인하죠",
          "논쟁이 길어지면 범위를 줄이겠습니다",
          "역할 경계 넘어가면 바로 도움 요청하겠습니다",
          "약속은 적고, 지켜지는 약속만 하겠습니다",
          "말투는 부드럽게, 기준은 분명하게",
          "좋은 의도 가정하고 시작합시다",
          "같은 목표를 바라보고 있다는 걸 자주 상기할게요",
          "실수는 덮기보다 배우는 걸로 정리합시다",
          "시간 존중하고 끝나면 바로 정리 공유하겠습니다",
          "결정했으면 뒤돌아보지 말고 밀겠습니다",
          "상대가 납득할 언어로 바꿔보겠습니다",
          "의견 차이는 자연스러운 거라 생각합니다",
          "다음 대화가 더 쉬워지게 오늘 기록 남기겠습니다"
        ]
      }
    },
  
    "Q4": {
      "A": {
        "target": [
          "목표를 조정하거나 범위를 축소해 효율을 높인다",
          "업무를 재배분해 속도를 확보한다",
          "핵심 목표에 집중해 추진력을 높인다",
          "리소스를 최적화하여 일정을 맞춘다",
          "불필요한 작업을 줄여 효율을 극대화한다",
          "목표 좀 줄이고 가능한 만큼 하죠",
          "일정 맞추려면 핵심만 남겨야 해요",
          "할 일 나눠서 빠르게 처리합시다",
          "지금 리소스로 할 수 있는 만큼 하죠",
          "중요한 부분만 먼저 끝내겠습니다",
          // 확장-전문형
          "스코프 슬라이싱으로 핵심만 남긴다",
          "리소스 재배분으로 크리티컬 작업에 집중한다",
          "Non-core는 다음 스프린트로 이관한다",
          "페이스 조절로 데드라인을 지킨다",
          "핵심 성과지표에 직결되는 것부터 끝낸다",
          // 확장-일상형
          "목표 조금 줄이고 중요한 것만 하죠",
          "지금 가능한 만큼 집중하죠",
          "우선 핵심만 완주합시다",
          "중요한 일부터 처리하겠습니다",
          "필요한 것만 남기겠습니다",
          // 확장-밀크T 맥락형
          "AI 추천 정확도 튜닝은 2차로 미루고 노출 안정화합니다",
          "학습 진입 속도 개선을 최우선으로 집중합니다",
          "과제/해설 핵심 화면만 리뉴얼 우선 적용합니다",
          "알림 리마인더는 MVP 사양으로 축소합니다",
          "대시보드 리포트는 텍스트 버전으로 대체합니다",
          // 확장-일상형(추가)
          "지금은 넓게 말고 얇고 빠르게 갑시다",
          "빼도 되는 건 과감히 빼죠",
          "핵심 루트만 먼저 뚫고 가요",
          "이번 스프린트엔 필수만 태웁시다",
          "효과 대비 시간이 큰 것만 남기죠",
          "병목 만드는 기능은 잠깐 내려놓죠",
          "한 번에 다 하려면 다 무너져요",
          "우선 완주하고, 다음에 살 찌우죠",
          "크게 말고 쪼개서 끝내는 걸로",
          "임팩트 높은 것 위주로 태워요",
          "할 일 줄이면 속도는 자연히 나옵니다",
          "일단 통로만 만들고 디테일은 다음 라운드로",
          "이번에선 성숙도보다 도달을 우선합시다",
          "중요한 화면만 다듬고 나머진 후퇴적 개선",
          "리소스 맞춰서 다시 배치하겠습니다",
          // 확장-일상형(추가2)
          "좋은 것보다 필요한 것부터 챙깁시다",
          "지금은 선택과 집중이 답이에요",
          "핵심을 남기고 주변을 비워냅시다",
          "결정이 늦으면 일이 밀립니다, 지금 자르죠",
          "욕심 줄이고 결과를 먼저 만듭시다",
          "‘없어도 되는 것’부터 걷어냅시다",
          "볼륨보다 완주가 우선입니다",
          "낙수 효과 없는 건 뒤로 미룹시다",
          "의존성 높은 건 다음 라운드로 분리해요",
          "최소 단위로 쪼개서 하나씩",
          "선택지를 줄이면 속도가 납니다",
          "지금 할 일과 다음에 할 일을 분명히 나눕시다",
          "완성도는 다음 릴리즈에서 높이죠",
          "핵심 경험만 보존하고 나머지는 얇게",
          "일단 열어 두고 꾸준히 덧칠하면 됩니다",
          "대체 가능한 건 당장 대체합시다",
          "지금 자원에서 최적해를 찾죠",
          "처음부터 완벽 말고 점진적으로",
          "작게 이겨가며 큰 걸 준비합시다",
          "바로 의미를 만드는 일에 집중하죠",
          "일정을 먼저 지키고 다음에 확장합시다",
          "지금 빼면 나중에 넣을 수 있습니다",
          "우선순위만 명확하면 절반은 끝입니다",
          "시간 먹는 장식은 잠시 접어두죠",
          "핵심 목표만 팀 전체에 걸로 맞추겠습니다",
          "효율이 안 나오는 건 과감히 스톱",
          "한 번에 끝내려 하지 말고 반복으로",
          "‘좋으면 좋고, 없어도 그만’은 뒤로",
          "일정과 품질 사이에서 지금은 일정",
          "이번 라운드는 뼈대만 세웁니다"
        ]
      },
      "B": {
        "target": [
          "완성도와 품질 유지를 최우선으로 한다",
          "팀의 상태를 살피며 지원한다",
          "도움을 제공하고 케어를 강화한다",
          "병목을 해소하며 일정 정리를 돕는다",
          "속도보다 안정적 마감을 중시한다",
          // 확장-전문형
          "완성도 저하를 막기 위해 품질 기준을 유지한다",
          "병목 구간에 직접 지원하고 장애물을 제거한다",
          "번아웃 방지를 위해 페어링/리뷰로 돕는다",
          "일정 정리를 PM이 선도해 부담을 낮춘다",
          "리스크 높은 태스크에 가드레일을 친다",
          // 확장-일상형
          "속도보다 완성도부터 챙기겠습니다",
          "제가 일정 정리 도울게요",
          "무리하지 않고 안정적으로 마감하죠",
          "팀원들의 기를 복돋아준다",
          "팀 분위기부터 살려야죠",
          "품질 떨어지지 않게 받쳐드릴게요",
          "상황에 맞게 유연하게 대처하는 것이 필요하다다",
          // 확장-밀크T 맥락형
          "테스트 케이스를 먼저 작성해 QA를 돕겠습니다",
          "성능 이슈 화면은 재현 로그를 제공하겠습니다",
          "CS 예상 문의를 미리 정리하겠습니다",
          "학부모 커뮤니케이션 문안을 준비하겠습니다",
          "릴리즈 노트를 책임지고 작성하겠습니다",
          // 확장-일상형(추가)
          "팀이 버티는 게 먼저예요",
          "지금 컨디션부터 챙기죠",
          "필요하면 제가 직접 붙겠습니다",
          "막힌 곳 있으면 저한테 바로 요청 주세요",
          "페어링으로 같이 뚫어보죠",
          "리뷰는 제가 빠르게 돌릴게요",
          "기술 부채는 목록화해서 불안 줄입시다",
          "스펙 모호하면 제가 문서로 정리하겠습니다",
          "우선순위 재조정해서 숨통부터 트죠",
          "야근 말고 범위 정리로 해결합시다",
          "품질 기준선만은 절대 안 내려요",
          "팀 사기 올리는 게 지금 성과에요",
          "불확실성 제거가 최고의 가속입니다",
          "리스크 높은 건 가드레일부터 칠게요",
          "제가 방패 설게요, 여러분은 품질에 집중해주세요",
          // 확장-일상형(추가2)
          "오늘 좋은 컨디션이면 내일도 잘 갑니다",
          "무리하면 다음 주에 더 느려져요",
          "도움이 필요하면 먼저 손들게요",
          "한 번에 완벽 말고 점검하며 가죠",
          "문제 감추지 말고 바로 공유하는 걸로",
          "불필요한 회의 줄이고 작업 시간 늘릴게요",
          "칭찬 먼저, 개선은 구체적으로",
          "일정이 꼬이면 제가 직접 풀러 가겠습니다",
          "핵심 담당은 과부하 걸리지 않게 나누죠",
          "막힌 구간은 빠르게 스와핑합시다",
          "휴식이 있어야 품질이 나옵니다",
          "테스트 시간은 일정에 처음부터 넣겠습니다",
          "리스크 리스트를 매일 업데이트하죠",
          "문서 하나로 모두 같은 페이지에 서게 합시다",
          "지금은 속도보다 안정이 팀을 지킵니다",
          "작은 승리라도 매일 만들고 공유해요",
          "질문하기 쉬운 분위기를 유지합시다",
          "실수는 빠르게 인정하고 고치는 걸로",
          "서로의 시간을 존중하는 운영을 하겠습니다",
          "막판 스퍼트보다 초반 정리가 더 중요해요",
          "체력 배분도 전략입니다",
          "퇴근 시간은 지켜야 다음이 있습니다",
          "작업 착수 전 정의부터 명확히 합시다",
          "검토는 짧고 자주, 수정보단 예방",
          "문제의 주인을 찾기보다 해결의 주인을 씁시다",
          "팀의 ‘왜’를 공유하면 ‘어떻게’가 쉬워집니다",
          "중요 공지는 한 번 더 확인합니다",
          "작업 종료 후 회고로 바로 개선점을 남기죠",
          "품질은 합의한 기준으로 판단하겠습니다",
          "안정적으로 마감하는 게 최고의 성과입니다"
        ]
      }
    },
  
    "Q5": {
      "A": {
        "target": [
          "성과와 성장 지표를 설정하고 관리한다",
          "신규 유입과 전환율 향상을 목표로 한다",
          "매출과 KPI 성과를 중심으로 판단한다",
          "지표 기반으로 성장을 측정한다",
          "데이터로 성과를 추적하고 보고한다",
          "성과를 좀 내봐야죠",
          "유입이나 매출을 늘려야겠어요",
          "지표로 확인해볼게요",
          "결과를 수치로 보고 싶어요",
          "이번엔 수치로 성장 보여줄게요",
          // 확장-전문형
          "신규 학습자 10% 유입을 KPI로 설정한다",
          "전환율·ARPU·CAC를 관리한다",
          "추천 기능의 클릭률·완료율을 목표로 둔다",
          "랜딩/스토어 최적화로 유입을 확장한다",
          "성과 기반 루프를 구축한다",
          // 확장-일상형
          "지표로 성과를 확인하겠습니다",
          "데이터로 보여드리겠습니다",
          "KPI로 관리하겠습니다",
          "전환을 올리는 데 집중하겠습니다",
          "유입을 늘려야 할 것 같아요",
          // 확장-밀크T 맥락형
          "추천 클릭률/학습 시작률을 올리겠습니다",
          "앱 설치→회원가입 전환을 개선하겠습니다",
          "학부모 리마인더 열람률을 높이겠습니다",
          "무료→유료 전환율을 끌어올리겠습니다",
          "재방문 주기를 단축하겠습니다",
          // 확장-일상형(추가)
          "이번 분기엔 숫자로 증명하겠습니다",
          "유입-전환-매출 선순환 만들죠",
          "퍼널 새는 구간 틀어막겠습니다",
          "핵심 지표 몇 개만 꽉 잡을게요",
          "목표는 명확하게, 숫자는 솔직하게",
          "지표판으로 매주 트래킹하겠습니다",
          "AB 테스트로 전환을 키우죠",
          "스토어 전환부터 손봐서 유입 늘리겠습니다",
          "온보딩 완주율이 제일 빠른 레버 같아요",
          "추천 클릭률 1%p만 올려도 임팩트 큽니다",
          "리텐션이 받쳐줘야 성장이에요, 주단위로 보죠",
          "숫자가 좋아지면 이야기도 좋아집니다",
          "각 채널 CAC 비교해서 효율 높은 곳에 태웁시다",
          "목표는 명확히: 신규 +10%, 전환 +2%p",
          "대시보드에 매일 아침 자동 리포트 올릴게요",
          // 확장-일상형(추가2)
          "보이는 숫자부터 바꾸면 팀이 달라집니다",
          "작은 지표라도 꾸준히 올리겠습니다",
          "전환 한 끗이 매출 한 줄을 만듭니다",
          "유입 늘리고 새는 곳 막으면 성장은 따라옵니다",
          "목표는 적고 정확하게 잡겠습니다",
          "가설-실험-학습을 빠르게 돌릴게요",
          "실험판은 작게, 효과는 크게 가져가죠",
          "상단 배너만 바꿔도 반응이 달라질 수 있어요",
          "첫 화면 문구만 정리해도 전환이 오릅니다",
          "가입 단계 줄이면 설치가 살아납니다",
          "우리에게 가장 쉬운 레버부터 당기겠습니다",
          "채널 예산을 성과 기준으로 재배치할게요",
          "핵심 경로만 매끈하게 만들면 됩니다",
          "데일리 스탠드업에서 지표 한 줄로 공유하죠",
          "목표를 달 표로 만들고 매일 체크하겠습니다",
          "숫자가 나쁘면 방법을 바꾸겠습니다",
          "숫자가 좋으면 더 밀어보겠습니다",
          "전환을 방해하는 한 문장부터 고치겠습니다",
          "리텐션을 주간 미션으로 붙여보죠",
          "복잡한 건 빼고 쉬운 것부터 이기겠습니다",
          "목표는 팀이 외울 수 있게 짧게",
          "성과는 캡처로 바로 공유하겠습니다",
          "실험은 겹치지 않게 순서대로",
          "데이터가 말하는 방향으로 가겠습니다",
          "달성률보다 학습량을 먼저 챙길게요",
          "작은 성공을 쌓아 큰 도약을 만들겠습니다",
          "숫자 앞에서는 솔직하게 보고하겠습니다",
          "일주일마다 성과 회고를 고정으로 하죠",
          "지표가 좋아지는 일을 더 하겠습니다",
          "지표가 나빠지는 일은 멈추겠습니다"
        ]
      },
      "B": {
        "target": [
          "사용자 만족과 경험 품질을 중시한다",
          "피드백과 평가 결과를 반영한다",
          "고객 충성도와 감정적 만족을 높인다",
          "사용자 중심으로 서비스 품질을 개선한다",
          "경험 데이터를 기반으로 개선한다",
          // 확장-전문형
          "학생 만족도 80% 이상을 목표로 한다",
          "NPS/CSAT/재방문률로 경험 품질을 관리한다",
          "입소문/추천 유입이 발생하도록 만족을 설계한다",
          "피드백 기반으로 서비스 품질을 개선한다",
          "이탈보다 충성도 강화에 집중한다",
          // 확장-일상형
          "만족도가 높으면 입소문이 납니다",
          "좋은 경험이 신규 유입까지 이어져요",
          "사용자 중심으로 품질을 올리겠습니다",
          "후기/리뷰가 좋아지게 만들겠습니다",
          "불편을 줄여서 계속 쓰게 하겠습니다",
          "기존 고객을 유지하기 위해서",
          "사용자가 계속해야 써야 상품이 의미 있어요",
          // 확장-밀크T 맥락형
          "학습 성취감과 동기 부여를 높이겠습니다",
          "오류·지연을 줄여 경험을 개선하겠습니다",
          "학부모 신뢰도를 올려 재등록을 늘리겠습니다",
          "해설 품질과 피드백을 다듬겠습니다",
          "알림·과제 리마인더로 만족을 높이겠습니다",
          // 확장-일상형(추가)
          "사용자가 좋아해야 진짜 성장입니다",
          "리뷰 한 줄이 유입 열 줄이에요",
          "작은 불편부터 바로바로 없앨게요",
          "속도보다 매끄러운 경험이 오래갑니다",
          "신뢰는 느리게 쌓이고 빨리 무너져요",
          "감정선 건드리지 않는 게 중요합니다",
          "장기적으로 남는 건 만족이에요",
          "재방문하고 싶게 만드는 게 목표예요",
          "NPS 한 점 올리는 데 집중하죠",
          "CS 줄어들면 그게 품질의 증거입니다",
          "학생이 성취감 느끼면 자연히 돌아옵니다",
          "학부모 안심 지점부터 설계합시다",
          "문제 없게 만드는 것보다, 좋아지게 만들죠",
          "사용자 말에 먼저 귀 기울이는 게 답입니다",
          "경험의 매끈함이 결국 매출을 이깁니다",
          // 확장-일상형(추가2)
          "유저가 편하면 숫자는 따라옵니다",
          "리뷰 좋아지면 광고보다 세요",
          "한 번 더 쓰고 싶게 만드는 게 본질입니다",
          "작은 칭찬 포인트를 곳곳에 심겠습니다",
          "속도는 빠르되 거칠지 않게 하죠",
          "오류 없는 하루가 최고의 마케팅입니다",
          "사용자 말을 먼저 기록하겠습니다",
          "불편 접수되면 하루 안에 회신하겠습니다",
          "도움 주는 문구 하나가 경험을 바꿉니다",
          "첫 경험에서 ‘좋다’를 만들어보죠",
          "신뢰는 약속을 지키며 쌓입니다",
          "불안 요소는 보이기 전에 없애겠습니다",
          "사용자의 시간을 아껴주는 게 품질입니다",
          "과제 끝났을 때의 성취감을 키우겠습니다",
          "‘다음에 또 와야지’가 나오게 만들죠",
          "불평 한 줄이 사라지면 추천 한 줄이 옵니다",
          "가끔의 감동이 오래 남습니다",
          "잘 작동하는 침묵도 품질입니다",
          "복잡한 건 덜고 필요한 건 더하겠습니다",
          "도움이 필요한 순간에 먼저 손을 내밀게요",
          "기대 이하를 없애고 기대 이상을 심겠습니다",
          "사용자에게 예측 가능한 경험을 주겠습니다",
          "눈치 보지 않게, 설명은 명확하게",
          "일관성이 신뢰를 만듭니다",
          "불편은 바로 고치고 개선은 계획적으로",
          "후기는 정성으로, 답변은 빠르게",
          "만족은 수치가 아니라 마음에서 시작합니다",
          "좋은 경험이 브랜드를 만듭니다",
          "사용자 중심에서 다시 출발하겠습니다",
          "오늘 조금 더 좋아지게 하겠습니다"
        ]
      }
    }
  };
  

// 시나리오 짧은 설명 함수
function getScenarioShort(questionId) {
    const scenarios = {
        'Q1': "회사 상품 매출 급감 문제 해결 방법 선택",
        'Q2': "경쟁사 대응을 위한 출시 전략 결정", 
        'Q3': "팀 내 갈등 상황에서의 중재 방식",
        'Q4': "일정 압박 상황에서의 리더십 스타일",
        'Q5': "프로젝트 목표 지표 설정 방향"
    };
    return scenarios[questionId] || "PM 의사결정 시나리오";
}

// 의도 프리셋에서 타겟 의도 추출 함수
function getIntents(question_id, selected_option) {
    const set = INTENT_PRESETS[question_id][selected_option];
    return { target_bullets: set.target };
}

// 동적 예시 선택 함수 (의미 기반 분석으로 유사한 예시 선별)
function selectRelevantExamples(userReason, allExamples, maxExamples = 5) {
    if (!userReason || allExamples.length <= maxExamples) {
        return allExamples.slice(0, maxExamples);
    }
    
    const userReasonLower = userReason.toLowerCase();
    
    // 의미 기반 키워드 매핑 (더 정교한 분석)
    const semanticKeywords = {
        // Q1-A (직접 체험/현장) 관련
        '직접체험': ['직접', '써보', '체험', '현장', '고객입장', '사용자입장', '실제', '몸으로', '손으로', '만져보', '눌러보'],
        '문제발견': ['불편', '문제', '이상', '확인', '점검', '체크', '발견', '찾아', '알아보'],
        '사용자관점': ['고객', '사용자', '입장', '관점', '처럼', '입장에서', '관점에서'],
        
        // Q1-B (데이터/분석) 관련  
        '데이터분석': ['데이터', '수치', '지표', '로그', '분석', '패턴', '통계', '측정', '정량'],
        '이탈분석': ['이탈', '전환율', '퍼널', '단계', '구간', '지점', '확인', '찾아'],
        '수치기반': ['숫자', '값', '비율', '율', '퍼센트', '수치로', '지표로'],
        
        // Q2-A (빠른 출시/선점) 관련
        '빠른출시': ['빠르', '빨리', '서둘', '즉시', '먼저', '신속', '재빨리'],
        '시장선점': ['선점', '시장', '점유', '경쟁사', '먼저', 'first', 'market'],
        '실험적접근': ['실험', '테스트', '시도', '해보', '시작', '도전'],
        
        // Q2-B (품질/검증) 관련
        '품질중시': ['품질', '완성도', '검증', '테스트', '확인', '완성'],
        '리스크관리': ['리스크', '위험', '안전', '신중', '확실', '보장'],
        '브랜드보호': ['브랜드', '이미지', '평판', '신뢰', '신뢰도', '명성'],
        
        // Q3-A (일정/우선순위) 관련
        '일정관리': ['일정', '시간', '스케줄', '계획', '우선순위', '순서'],
        '효율성': ['효율', '빠르', '신속', '효과적', '최적화', '개선'],
        '현실적접근': ['현실', '가능', '실행', '구체', '명확', '실제'],
        
        // Q3-B (협업/소통) 관련
        '협업': ['협업', '팀', '함께', '공동', '협력', '조율'],
        '소통': ['소통', '대화', '이야기', '의견', '논의', '상의'],
        '공감': ['공감', '이해', '배려', '상대', '입장', '감정'],
        
        // Q4-A (목표조정/집중) 관련
        '목표조정': ['목표', '조정', '변경', '수정', '바꿔', '다시'],
        '집중': ['집중', '핵심', '중요', '우선', '먼저', '선택'],
        '효율성': ['효율', '빠르', '신속', '효과적', '최적화', '개선'],
        
        // Q4-B (지원/케어) 관련
        '지원': ['지원', '도와', '돕', '케이어', '복돋', '응원'],
        '품질유지': ['품질', '완성도', '안정', '확실', '보장', '유지'],
        '팀관리': ['팀', '분위기', '상태', '관리', '케어', '배려'],
        
        // Q5-A (성과/지표) 관련
        '성과중심': ['성과', '결과', '성취', '달성', '목표', '실적'],
        '지표관리': ['지표', '수치', 'KPI', '측정', '관리', '추적'],
        '성장': ['성장', '증가', '향상', '개선', '발전', '확장'],
        
        // Q5-B (만족/경험) 관련
        '사용자만족': ['만족', '경험', '사용자', '고객', '피드백', '후기'],
        '감정적가치': ['감정', '느낌', '인상', '체감', '만족감', '기분'],
        '장기적관점': ['장기', '지속', '계속', '유지', '안정', '지속성']
    };
    
    const scoredExamples = allExamples.map(example => {
        const exampleLower = example.toLowerCase();
        let totalScore = 0;
        
        // 1. 직접 단어 매칭 점수 (기존 방식)
        const userWords = userReasonLower.split(/\s+/);
        const exampleWords = exampleLower.split(/\s+/);
        const directMatches = userWords.filter(word => 
            exampleWords.some(exampleWord => 
                exampleWord.includes(word) || word.includes(exampleWord)
            )
        ).length;
        totalScore += directMatches * 2; // 직접 매칭은 높은 가중치
        
        // 2. 의미 기반 키워드 매칭 점수
        for (const [category, keywords] of Object.entries(semanticKeywords)) {
            const userHasCategory = keywords.some(keyword => userReasonLower.includes(keyword));
            const exampleHasCategory = keywords.some(keyword => exampleLower.includes(keyword));
            
            if (userHasCategory && exampleHasCategory) {
                totalScore += 3; // 의미적 일치 시 높은 점수
            } else if (userHasCategory || exampleHasCategory) {
                totalScore += 1; // 부분적 일치 시 낮은 점수
            }
        }
        
        // 3. 문장 구조 유사성 점수
        const userLength = userReason.length;
        const exampleLength = example.length;
        const lengthSimilarity = 1 - Math.abs(userLength - exampleLength) / Math.max(userLength, exampleLength);
        totalScore += lengthSimilarity;
        
        return { example, score: totalScore };
    });
    
    // 점수 순으로 정렬하고 상위 예시들 선택
    const selected = scoredExamples
        .sort((a, b) => b.score - a.score)
        .slice(0, maxExamples)
        .map(item => item.example);
    
    console.log(`🎯 의미 기반 예시 선택 상세:`);
    console.log(`  - 사용자 입력: "${userReason}"`);
    console.log(`  - 선택된 예시 점수들:`, scoredExamples.slice(0, maxExamples).map(item => ({ example: item.example.substring(0, 30) + '...', score: item.score })));
    
    return selected;
}

// LLM-Judge 프롬프트 문자열 생성 함수
function buildJudgePrompt({question_id, selected_option, scenario_short, reason}) {
    const { target_bullets } = getIntents(question_id, selected_option);
    
    // 동적 예시 선택 (사용자 입력과 유사한 예시만 5개 선택)
    const selectedExamples = selectRelevantExamples(reason, target_bullets, 5);
    
    console.log(`🎯 동적 예시 선택 결과:`);
    console.log(`  - 전체 예시 수: ${target_bullets.length}`);
    console.log(`  - 선택된 예시 수: ${selectedExamples.length}`);
    console.log(`  - 선택된 예시들:`, selectedExamples);
    
    return `
[Role]
You are a strict LLM judge that scores how well a user's short reason matches a target product-management intent.

[Task]
Return a strict JSON only (no prose), scoring 0–10 by meaning (not keywords).

[Context]
- Question ID: ${question_id}
- Selected Option: ${selected_option}
- Scenario (one line): ${scenario_short}

- Target intent (bullets, 3–5):
${selectedExamples.map(b=>"- "+b).join("\n")}

[User Reason]
"${reason}"

[Scoring Rubric]
- 8–10: Clearly matches target intent with concrete alignment (actions, purpose, logic).
- 5–7 : Partially matches; intent is present but incomplete or generic.
- 3–4 : Weakly related; vague or tangential.
- 0–2 : Misaligned or off-topic.
- Synonymous expressions like "competitor first", "faster than others", "market advantage" should receive full credit if they express the target intent.
- 일상적 표현(예: '먼저 할게요', '중요한 것부터 해볼게요', '팀이 피곤하니까 쉬면서 하자', '고객 입장에서 한번 써볼게요')이라도, 핵심 의도(Qx-A/B)의 방향과 일치하면 7점 이상으로 평가하라.

[Output JSON Schema]
{
  "semantic_relevance": <float 0..10>,  // one decimal
  "confidence": <float 0..1>,           // judge's confidence
  "rationale": "<max 1 short sentence>"
}

[Constraints]
- Do not rely on specific keywords; evaluate intent, behavior, purpose, logic.
- Ignore spacing, punctuation, and formatting differences - focus only on semantic meaning.
- Examples of equivalent responses: "사용자입장에서체험", "사용자 입장에서 체험", "사용자  입장에서   체험" should receive the same score.
- Return valid JSON only. No extra text.
`.trim();
}

// LLM-Judge 방식으로 의미 기반 점수 계산 (0~10)
async function calculateSemanticModel(reason, questionId, selectedOption) {
    try {
        const scenarioShort = getScenarioShort(questionId);
        const normalizedReason = normalizeText(reason); // 텍스트 정규화 적용
        const prompt = buildJudgePrompt({
            question_id: questionId,
            selected_option: selectedOption,
            scenario_short: scenarioShort,
            reason: normalizedReason
        });
        
        // AI 채점 시간 측정 시작
        const scoringStartTime = performance.now();
        console.log(`⏱️ AI 채점 시작 - 문항: ${questionId}, 선택지: ${selectedOption}`);
        
        const response = await callOpenAIForScoring(prompt);
        
        // AI 채점 시간 측정 종료
        const scoringEndTime = performance.now();
        const scoringDuration = scoringEndTime - scoringStartTime;
        console.log(`⏱️ AI 채점 완료 - 소요시간: ${scoringDuration.toFixed(2)}ms (${(scoringDuration/1000).toFixed(2)}초)`);
        
        // JSON 파싱 시도
        let result;
        try {
            result = JSON.parse(response.trim());
        } catch (parseError) {
            console.warn('JSON 파싱 실패, 재시도:', parseError);
            // 1회 재시도
            const retryResponse = await callOpenAIForScoring(prompt);
            try {
                result = JSON.parse(retryResponse.trim());
            } catch (retryError) {
                console.error('재시도도 실패, 보수적 처리:', retryError);
                return { semantic_relevance: 4.0, confidence: 0.3, rationale: "JSON 파싱 실패" };
            }
        }
        
        // 유효성 검증
        if (!result.semantic_relevance || isNaN(result.semantic_relevance) || 
            result.semantic_relevance < 0 || result.semantic_relevance > 10) {
            console.warn(`유효하지 않은 점수: ${result.semantic_relevance}, 보수적 처리`);
            return { semantic_relevance: 4.0, confidence: 0.3, rationale: "유효하지 않은 점수" };
        }
        
        // 의미판단 보정 (LLM 레벨)
        let correctedScore = result.semantic_relevance;
        const rationale = result.rationale || "";
        
        // LLM이 rationale에서 "의도에 부합" 또는 "aligned with intent"로 서술한 경우 자동 보정
        if (rationale.includes("의도에 부합") || rationale.includes("aligned with intent") || 
            rationale.includes("intent") || rationale.includes("부합")) {
            correctedScore = Math.max(correctedScore, 7.0);
            console.log(`🎯 LLM rationale 기반 자동 보정: ${result.semantic_relevance} → ${correctedScore}`);
        }
        
        // 중립형이지만 선택지 의도와 논리적 근거 방향이 같은 경우 보정
        const intentAlignmentKeywords = {
            'Q2': { 'B': ['리스크', '브랜드', '품질', '검증', '이미지', '평판', '신뢰도'] },
            'Q5': { 'B': ['만족', '경험', '피드백', '충성', '추천', '입소문', '지속이용', '사용자 중심'] },
            'Q3': { 'B': ['협업', '공감', '소통', '조율', '배려', '서로', '이해', '의견교환', '대화'] }
        };
        
        const keywords = intentAlignmentKeywords[questionId]?.[selectedOption] || [];
        const hasIntentAlignment = keywords.some(keyword => reason.toLowerCase().includes(keyword));
        
        if (hasIntentAlignment && correctedScore < 7.0) {
            correctedScore = Math.max(correctedScore, 7.0);
            console.log(`🎯 의도 정렬 키워드 기반 보정: ${result.semantic_relevance} → ${correctedScore}`);
        }
        
        console.log(`🤖 LLM-Judge 결과 (보정 후):`, { 
            ...result, 
            semantic_relevance: correctedScore,
            original_score: result.semantic_relevance 
        });
        
        return { 
            ...result, 
            semantic_relevance: correctedScore 
        };
        
    } catch (error) {
        console.error('LLM-Judge 점수 계산 오류:', error);
        return { semantic_relevance: 4.0, confidence: 0.3, rationale: "API 오류" };
    }
}

// OpenAI API 호출 함수 (점수 계산용) - gpt-3.5-turbo 사용
async function callOpenAIForScoring(prompt) {
    const messages = [
        {
            role: "system",
            content: "당신은 답변의 의미적 적합성을 평가하는 전문가입니다. 주어진 의도 축들을 기준으로 답변의 적합성을 0~10점으로 정확하게 평가해주세요."
        },
        {
            role: "user",
            content: prompt
        }
    ];
    
    const requestBody = {
        model: "gpt-3.5-turbo",
        messages: messages,
        max_tokens: 100,
        temperature: 0 // 완전히 일관된 점수 산출
    };
    
    const response = await fetch(OPENAI_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
        throw new Error(`API 호출 실패: ${response.status}`);
    }
    
    const data = await response.json();
    
    // 토큰 사용량 로깅
    if (data.usage) {
        console.log(`📊 토큰 사용량:`);
        console.log(`  - 입력 토큰: ${data.usage.prompt_tokens}`);
        console.log(`  - 출력 토큰: ${data.usage.completion_tokens}`);
        console.log(`  - 총 토큰: ${data.usage.total_tokens}`);
    }
    
    return data.choices[0].message.content;
}

// 동의어 사전 및 중립 단어 정의
// 동의어 사전 및 중립 단어 정의 (확장판)
const SYNONYM_LEXICON = {
    // Q1-A (직접 체험/현장)
    "직접": ["직접","바로","몸소","hands-on","핸즈온","직접 확인","손수",
             "스스로","당장","현장에서 바로","내 손으로","내가 직접","즉시","바로 해보기"],
    "써보": ["써보","써 본","사용해보","사용해 본","try","trial","테스트 사용","눌러보","눌러 보","만져보","만져 보","사용",
             "돌려보","돌려 보","체험해보","체험 해보","실행해보","실행 해보","한번 써보","쭉 써보","시연해보","시연 해보",
             "hands on","use it","try it","poke around","탐색해보","탐색 해보","찍먹","찍먹해보"],
    "느껴": ["느껴","체감","감지","직감","피감","감으로",
             "감이 오다","느낌 오다","느낌적인 느낌","손맛","손에 느껴져","바로 체감","바디체크",
             "쓰다 보면 보인다","써봐야 안다","손대보니 알겠다"],
    "만져": ["만져","손으로","직접 다뤄","다뤄 보","터치해 보","터치해보",
             "만지작","만지작해보","눌러대보","툭툭 건드려 보","fiddle with","tinker with","클릭클릭"],
    "현장": ["현장","실전","실사용","실환경","real world","real-life","실무 환경","실제",
             "실서비스","라이브 환경","프로덕션","운영 환경","현업","필드"],
    "고객": ["고객","사용자","유저","고객 관점","유저","user perspective","유저",
             "학생","학부모","end user","learner","parent user","실사용자"],
    "관점": ["관점","처럼","입장",
             "시각","포지션","관점에서","뷰","관점 전환","as a user","유저처럼"],
    "온보딩": ["온보딩","가입 과정","첫 사용","가입 플로우","onboarding",
               "첫 시작","초기 진입","웰컴 흐름","첫 실행","초기 세팅"],
    "결제플로우": ["결제 플로우","결제 흐름","결제 과정","checkout","결제 단계",
                   "구매 절차","구매 과정","결제 트랙","결제 퍼널"],
    "학습경로": ["학습 경로","학습 흐름","학습 플로우","learning flow","학습 시작",
                 "진도 흐름","커리큘럼 진행","학습 여정","러닝 패스"],
    "퀴즈해설": ["퀴즈","해설","문제 풀이","풀이 보기",
                 "문제 풀기","정답 확인","해설 보기","풀이 확인","퀴즈→해설"],
    "배지위젯": ["배지","배지 노출","위젯","badge","widget",
                 "뱃지","라벨","표식","아이콘 배지","위젯 노출"],
    "진입경로": ["진입 경로","엔트리","entry","진입 동선",
                 "들어오는 길","유입 경로","첫 클릭 경로","landing path"],
  
    // Q1-B (데이터/지표/로그)
    "데이터": ["데이터","data","데이타","데이터 기반",
               "정량","숫자 데이터","수집 데이터","raw data","로그 데이터"],
    "수치": ["수치","숫자","정량","수치화","metrics","값",
             "숫자값","수치 지표","계량","수량화"],
    "지표": ["지표","KPI","메트릭","지표값","인디케이터",
             "핵심 지표","성과 지표","metric","indicator","핵심 KPI"],
    "로그": ["로그","log","event log","이벤트 로그","분석 로그","이벤트 기록",
             "트래킹 로그","로그값","로그데이터","tracking"],
    "분석": ["분석","해석","분해","분석적","analytics","진단",
             "원인 분석","root cause","원인 파악","data analysis","insight 도출"],
    "패턴": ["패턴","경향","트렌드","추세","pattern",
             "동향","움직임","변화율 패턴","시그널"],
    "퍼널": ["퍼널","funnel","전환 깔때기","유입-전환","전환경로",
             "전환 흐름","전환 단계","conversion path","퍼널 단계"],
    "전환율": ["전환율","CVR","conversion rate","전환 비율",
               "완료율","가입 전환율","구매 전환율","결제 전환율"],
    "코호트": ["코호트","cohort","코호트 분석",
               "코호트 리텐션","세그먼트 잔존","집단 분석"],
    "잔존": ["잔존","리텐션","retention","잔존율",
             "재방문률","재이용률","잔존 지표","churn 반대"],
    "세션": ["세션","session","세션 수","평균 세션",
             "세션 길이","session length","session count","session time"],
    "애널리틱스": ["애널리틱스","analytics","GA","구글 애널리틱스","Amplitude","앰플리튜드",
                   "GA4","firebase analytics","분석 툴","BI"],
    "대시보드": ["대시보드","dashboard","지표판","모니터링 보드",
                 "보드","DBD","리포팅 보드","실시간 보드"],
    "이벤트로그": ["이벤트","event","이벤트 트래킹","event tracking",
                    "클릭 이벤트","스크린 뷰","page view","event tag"],
    "에러코드": ["에러 코드","오류 코드","error code","실패 코드",
                 "에러 타입","에러 리포트","예외 코드","status code"],
  
    // Q2-A (빠른 출시/선점/MVP)
    "빠르": ["빠르","빨리","즉시","신속","speedy","fast","재빨리","바로",
             "속도전","스피드","빠르게 가자","빨리 내자","속도 우선","퀵하게"],
    "서둘": ["서둘","서둘러","서두르","급히","급하게",
             "빠르게 진행","당겨서","앞당겨","타임어택","속도 올리자"],
    "먼저": ["먼저","선점","우선 출시","first mover","first-to-market","먼저 시작",
             "빠른 스타트","선빵","선공","first out","earlier launch"],
    "시장선점": ["시장 선점","시장 점유","점유","먼저 먹","선점 효과","market lead","market advantage","market dominance",
                "초기 점유","선점 이득","런칭 선점"],
    "선점": ["선점","시장선점","시장","시장 점유","점유","시장 점유율",
             "점유 확대","first in market","first win"],
    "경쟁사대비": ["경쟁사보다","경쟁사 대비","먼저 내","빠르게 출시","타사보다 먼저",
                   "경쟁보다 빠르게","타사 선행","경쟁 리드"],
    "브랜드인지도": ["브랜드 인지도","인지도","first mover","first-to-market","market advantage","market dominance",
                     "브랜딩 초반 선점","초기 노출 이득"],
    "MVP": ["MVP","최소기능","min viable","스몰 런칭","라이트 출시","작게 먼저",
            "얇게 시작","핵심만 출시","lean 버전","버전 0.1"],
    "학습루프": ["학습 루프","빠른 피드백","iterative","iteration","반복 개선","빠른 학습",
                "짧은 피드백 루프","빠른 사이클","빠른 회전"],
    "소프트런치": ["소프트런치","soft launch","조용히 배포","제한 배포",
                   "소규모 출시","그레이 릴리즈","스텔스 런칭"],
    "베타": ["베타","beta","베타 트랙","베타 테스트",
             "얼리엑세스","프리뷰 테스트","클로즈드 베타","오픈 베타"],
    "실험배포": ["실험 배포","실험적 배포","A/B 배포","그레이 롤아웃","점진적 배포",
                "스테이지드 롤아웃","부분 배포","실험 릴리즈"],
    "선공개": ["선공개","프리뷰","사전 공개",
              "티저 공개","스니크 피크","선행 노출"],
    "롤아웃": ["롤아웃","rollout","점진 배포",
              "순차 배포","그레이 배포","단계적 배포"],
  
    // Q2-B (품질/브랜드/리스크/검증)
    "검증": ["검증","validate","밸리데이션","검토","체크","확인 절차",
             "확증","유효성 확인","사전 점검","pre-check","검수"],
    "테스트": ["테스트","QA","품질 테스트","QA 테스트","테스팅","회귀 테스트","리그레션",
               "유닛 테스트","통합 테스트","시나리오 테스트","UAT","버그바시","버그바시(버그 바시)"],
    "브랜드": ["브랜드","brand","브랜드 이미지","브랜드 신뢰","기업 이미지",
               "브랜딩","브랜드 가치","브랜드 보호"],
    "평판": ["평판","reputation","명성","이미지",
             "대외 신뢰","대외 이미지","사회적 신뢰"],
    "신뢰도": ["신뢰도","trust","신뢰","credibility",
               "신뢰 확보","믿음","신뢰 지표"],
    "품질": ["품질","퀄리티","완성도","quality","완성","안정성",
             "완성도 기준","퀄리티 바","품질선","품질 게이트"],
    "리스크": ["리스크","위험","risk","부작용","리스크 관리","리스크 방지",
               "사고 위험","품질 리스크","운영 리스크"],
    "재출시": ["재출시","relaunch","다시 출시","롤백 후 재출시",
               "재런칭","재배포"],
    "롤백": ["롤백","rollback","되돌리기","버전 되돌림",
             "버전 회귀","버전 되돌리기"],
    "장애": ["장애","incident","장애 발생","장애 리스크",
             "다운타임","오류 폭발","서비스 중단","장애 이슈"],
    "CS폭주": ["CS 폭주","민원 폭주","문의 폭주","고객 항의",
               "티켓 폭주","콜 폭주","문의량 급증"],
    "리뷰": ["리뷰","후기","평","review",
             "사용자 리뷰","스토어 리뷰","평가글"],
    "평점": ["평점","rating","별점",
             "스토어 평점","별점 평균","별점 하락"],
    "근거노출": ["근거 노출","explanation","explainability","추천 근거",
                 "설명 가능성","근거 표시","설명 보기"],
    "가드레일": ["가드레일","guardrail","안전장치",
                 "세이프가드","보호장치","안전 기준"],
    "민원": ["민원","complaint","항의",
             "불만 접수","클레임","고객 불만"],
  
    // Q3-A (일정/우선순위/계획/스코프)
    "일정": ["일정","타임라인","스케줄","schedule","timing","계획","캘린더",
             "마감","데드라인","딜라인","타임박싱","타임라인 조정"],
    "우선순위": ["우선순위","priority","프라이오리티","선정","우선순위화",
                "순서 정하기","prio","우선도","선정 기준"],
    "대안": ["대안","옵션","대체안","방안","백업 플랜",
             "플랜B","대응안","보완안","차선책"],
    "현실적": ["현실적","실현 가능","feasible","실행 가능","실제",
               "현실 감안","가능 범위","합리적"],
    "계획": ["계획","플랜","plan","로드맵","roadmap",
             "스프린트 플랜","iteration plan","plan of record"],
    "영향도난이도": ["영향도","난이도","임팩트","코스트","impact effort","IE 매트릭스",
                    "효과/노력","효율/비용","효율대비임팩트"],
    "MoSCoW": ["MoSCoW","모스코우","must/should/could/won't",
               "모스코우 방식","must-have 분류"],
    "크리티컬패스": ["크리티컬 패스","critical path","주 경로",
                     "핵심 경로","필수 경로"],
    "버퍼": ["버퍼","buffer","시간 여유",
             "여유 시간","slack time","완충 구간"],
    "병목": ["병목","bottleneck","병목 구간",
             "막힌 구간","blocker","병목 포인트"],
    "마일스톤": ["마일스톤","milestone","중간 목표",
                 "중간 체크포인트","분기 목표","게이트"],
    "스코프": ["스코프","범위","scope","scope down","범위 축소",
               "범위 조정","컷오프","슬라이싱"],
    "이관": ["이관","defer","다음 스프린트로","뒤로 미룸",
             "일정 이월","postpone","rollover"],
  
    // Q3-B (공감/소통/조율/합의)
    "협업": ["협업","콜라보","co-work","협치","같이 하기",
             "함께 하기","공동 작업","팀업","워크 투게더"],
    "공감": ["공감","empathy","이해","감정 이입","공감대",
             "입장 이해","상대 입장 고려","서로 이해"],
    "소통": ["소통","커뮤니케이션","대화","커뮤","얘기 나눔",
             "대화로 풀기","대화 정리","대화 재개","소통 채널"],
    "조율": ["조율","합의","align","alignment","컨센서스","맞춰 보기",
             "합의점 찾기","중재","밸런싱","조정"],
    "배려": ["배려","케어","consideration","상대 입장","상호 존중",
             "감정 케어","톤 다운","격려","응원"],
    "공통안": ["공통안","공통 지점","공통 분모",
               "공유된 해법","합의된 기준","공통 조건"],
    "절충안": ["절충안","trade-off","타협안",
               "중간안","middle ground","折衷안"],
    "비동기": ["비동기","async","비동기 문서","비동기 커뮤니케이션",
               "비동기 정리","비동기 기록","문서로 합의"],
    "파킹랏": ["파킹랏","parking lot","보류 목록",
               "보류함","추후 검토","홀딩 리스트"],
    "논점정리": ["논점","핵심 쟁점","주요 포인트",
                 "이슈 정리","결정 포인트","핵심 의제"],
    "격화완화": ["격화","고조","완화","de-escalate",
                 "감정 누그러뜨리기","톤 조절","갈등 완화"],
  
    // Q4-A (목표 조정/재배분/집중)
    "목표": ["목표","타깃","goal","objective","목적",
             "목표치","타깃 수치","핵심 목표"],
    "조정": ["조정","스코프 조정","범위 축소","scope down","trim","정리",
             "슬림화","축소 조정","컷오프","리스코핑"],
    "재배분": ["재배분","리소스 재할당","resource reallocation","분담 조정",
              "리소스 이동","재할배","리소스 리밸런싱"],
    "효율": ["효율","효율화","효율적","효율성","efficiency",
            "레버리지","효율 높이기","낭비 제거","린(lean)화"],
    "집중": ["집중","focus","핵심 우선","핵심 선택","핵심 집중",
            "코어에 집중","포커스","핵심 몰입"],
    "슬라이싱": ["슬라이싱","slicing","작게 나누기",
                 "세분화","쪼개기","scope slicing"],
    "페이스조절": ["페이스 조절","pace control","속도 조절",
                   "호흡 조절","리듬 조절","페이스 튜닝"],
    "우선적용": ["우선 적용","선 적용","먼저 적용",
                "prioritize apply","early apply","core-first"],
    "축소": ["축소","축약","downsize",
             "trim down","cut down","스코프 줄이기"],
    "대체": ["대체","replace","텍스트 버전으로 대체",
             "간소 버전 대체","라이트 버전 대체","임시 대체"],
  
    // Q4-B (품질/지원/케어/리스크 가드)
    "완성도": ["완성도","완성","완결성","quality bar","퀄리티 바",
               "퀄바","완성도 기준","품질선","최소 품질선"],
    "지원": ["지원","서포트","support","백업","돕기",
             "백업 지원","현장 지원","옆에서 돕기","지원 사격"],
    "도와": ["도와","도움","헬프","help","받쳐주",
             "서포트하기","밀어주기","받쳐 드리기","손 보태기"],
    "케어": ["케어","돌봄","챙김","care","케어링","복돋","격려려",
             "멘탈 케어","사기 진작","사기 올리기","안부 체크","컨디션 체크","격려"],
    "품질우선": ["품질 우선","quality first","완성 우선","안정 우선",
                "퀄리티 퍼스트","안정성 퍼스트","품질 최우선"],
    "번아웃": ["번아웃","burnout","탈진",
               "소진","과로","overwork","피로 누적"],
    "페어링": ["페어링","pairing","페어 프로그래밍","페어 리뷰",
               "짝 진행","짝 리뷰","co-review","co-dev"],
    "리뷰": ["리뷰","review","코드 리뷰","디자인 리뷰",
             "PR 리뷰","문서 리뷰","테스트 리뷰"],
    "장애물제거": ["장애물 제거","blocker 제거","블로커 제거","unblock",
                 "방해요소 제거","막힌 부분 해소","허들 제거"],
  
    // Q5-A (성과/전환/유입)
    "성과": ["성과","performance","result","성과지표","결과",
             "결과 수치","결실","성과 개선","성과 관리"],
    "유입": ["유입","acquisition","inflow","traffic in",
             "신규 유입","트래픽 유입","유입량","채널 유입"],
    "성장": ["성장","growth","스케일","scale","확장",
             "스케일업","지표 성장","규모 확대","성장률"],
    "매출": ["매출","revenue","수익","GMV",
             "매출액","매출 증대","ARPU 상승","수익화"],
    "퍼센트": ["퍼센트","%","percent","비율","율","증가율",
               "퍼센티지","포인트","p","p 상승","p 개선"],
    "KPI": ["KPI","핵심 지표","핵심성과",
            "핵심 성과지표","key metric","핵심 KPI"],
    "CTR": ["클릭률","CTR","click-through rate",
            "클릭 비율","클릭 전환"],
    "진입률": ["진입률","entry rate","진입 비율",
              "진입 전환","entry conversion"],
    "ARPU": ["ARPU","유저당 매출","평균 매출",
             "평균 매출액","per user revenue"],
    "CAC": ["CAC","획득비용","고객획득비용",
            "acq cost","acquisition cost","채널 CAC"],
    "스토어최적화": ["스토어 최적화","ASO","앱스토어 최적화",
                   "스토어 전환 최적화","스토어 카드 최적화"],
    "랜딩최적화": ["랜딩 최적화","LPO","랜딩 페이지 최적화",
                  "랜딩 전환 최적화","landing opt"],
    "재방문주기": ["재방문 주기","return cycle","방문 주기 단축",
                  "복귀 주기","리텐션 주기","방문 간격"],
  
    // Q5-B (만족/경험/충성/입소문)
    "만족": ["만족","만족도","satisfaction","happy","만족감",
             "기쁨","좋아요","맘에 듦","만족 지표"],
    "경험": ["경험","UX","사용경험","사용자 경험","경험 품질",
             "서비스 경험","사용감","경험 지표","체감 품질"],
    "평가": ["평가","평가점수","점수","rating","CSAT",
             "만족도 점수","후기 점수","설문 점수"],
    "피드백": ["피드백","feedback","후기","리뷰",
              "코멘트","사용자 의견","고객 목소리","VOC"],
    "충성": ["충성","충성도","LTV","재방문","retention","로열티",
            "재이용","재등록","충성 고객","충성 지표"],
    "사용자중심": ["사용자 중심","user-centric","고객 중심","user first","유저 중심",
                  "customer first","유저 퍼스트","사용자 우선"],
    "NPS": ["NPS","추천지수","순추천지수",
           "추천 의향 점수","net promoter score"],
    "CSAT": ["CSAT","고객만족도","만족도 점수",
             "customer satisfaction","만족 점수"],
    "입소문": ["입소문","word of mouth","추천",
              "자연 유입","바이럴","입소문 효과","추천 유입"],
    "추천유입": ["추천 유입","referral","추천으로 신규 유입",
                "추천 코드 유입","지인 추천 유입"],
    "재방문": ["재방문","재이용","다시 방문","repeat visit",
             "복귀","리턴 방문","재사용"]
  };
  
  
  const NEUTRAL_WORDS = [
    // 기본 근거형 문장 패턴
    "왜냐하면", "때문에", "기 때문이다", "해서", "이라서", "이기 때문에", "이라 하기보다", 
    "이라 생각해서", "이라 판단해서", "이라 느껴서", "이라 보기 때문에", "해서 그렇습니다",
    "이유로", "근거로", "기반으로", "바탕으로", "입각해서", "근거하여", "보고 판단했습니다",
  
    // 객관적 이유 표현
    "상황상", "현재 상황을 보면", "현실적으로", "여건상", "조건상", "타이밍상", "환경상",
    "지표상", "데이터상", "결과상", "흐름상", "문맥상", "맥락상", "사실상", "추세상",
    "보통 그렇기 때문에", "일반적으로 그렇기 때문입니다", "전례상", "이전 사례상",
  
    // 논리적 판단 근거
    "논리적으로", "객관적으로", "이성적으로", "합리적으로", "근거 있게", "정황상", "판단상", 
    "판단해보면", "이해해보면", "흐름상 그렇게 됩니다", "상황을 고려하면", "그럴 가능성이 높습니다", 
    "그럴 여지가 있습니다", "그럴 확률이 높습니다", "이전 패턴을 보면", "데이터를 보면",
    "수치상으로 보면", "경험상", "직접 경험상", "사례를 보면", "일반적으로 보면",
  
    // 설명형 근거 표현
    "결과적으로", "요약하자면", "정리하자면", "종합적으로", "한마디로", "결론적으로",
    "즉", "결국", "한편으로는", "다른 한편으로는", "상대적으로", "상황을 종합해보면",
    "이전 흐름을 보면", "현재 기준으로 보면", "지금 시점에서는", "그 시점 기준으로 보면",
  
    // 판단의 이유를 덧붙이는 표현
    "그래서", "그렇기 때문에", "그 결과", "그로 인해", "그 영향으로", "그 여파로", "그런 이유로",
    "그런 점에서", "그런 관점에서", "그런 맥락에서", "그렇게 보는 게 맞습니다", 
    "그렇게 이해했습니다", "그렇게 판단했습니다", "그게 더 자연스럽기 때문입니다",
  
    // 중립적 원인·조건 연결어
    "때", "조건에서", "상황에서", "경우에", "때문이라기보단", "원인으로", "요소로", "기여해서",
    "작용해서", "영향을 줘서", "영향을 받아서", "결정된 이유는", "기준은", "핵심 요인은",
    "주된 이유는", "직접적인 이유는", "보조적인 이유는",
  
    // 실무·설명형 자연어 이유 표현
    "일정상", "우선순위상", "시간상", "리소스상", "인력상", "기한상", "목표상", "역할상", 
    "구조상", "절차상", "프로세스상", "조직상", "규정상", "정책상", "업무상",
    "여러 사정을 고려해", "리스크를 고려해", "효율을 고려해서", "품질을 고려해서", 
    "속도를 고려해서", "균형을 고려해서", "상황을 고려해 결정했습니다", "전체 일정상 그렇게 됐습니다",
  
    // 객관적인 이유 정리 표현 (설명·보고형)
    "그게 가장 합리적이라 판단했습니다",
    "가장 효율적이라 생각했습니다",
    "리스크가 적어서 선택했습니다",
    "현실적으로 가능한 방향이라서요",
    "여건상 그게 맞는 판단이었습니다",
    "데이터상 가장 자연스러운 결과입니다",
    "상황상 그렇게 판단했습니다",
    "전체 일정상 그렇게 결정했습니다",
    "리소스를 고려하면 그게 맞습니다",
    "효율성을 고려하면 그게 적절합니다",
    "여러 조건을 고려했을 때 최선의 선택이었습니다",
    "리스크를 줄이기 위해서입니다",
    "혼선을 줄이기 위해서 그렇게 했습니다",
    "명확한 기준을 두기 위해서입니다",
    "우선순위를 맞추기 위해서입니다",
    "속도와 품질의 균형을 맞추기 위해서입니다",
    "결과를 명확히 보기 위해서입니다",
    "데이터 근거를 확보하기 위해서입니다",
    "리뷰 과정에서 그렇게 정리됐습니다",
    "공통된 기준을 만들기 위해서입니다"
  ];
  

// 동의어 확장 함수
function expandSynonyms(keywords) {
    const expanded = [];
    for (const keyword of keywords) {
        expanded.push(keyword); // 원본 키워드 추가
        if (SYNONYM_LEXICON[keyword]) {
            expanded.push(...SYNONYM_LEXICON[keyword]); // 동의어들 추가
        }
    }
    return [...new Set(expanded)]; // 중복 제거
}

// 규칙 기반 보정값 계산 (LLM 보정형 v2.1)
function calculateRuleAdjustment(text, scenario, selectedOption) {
    let adjustment = 0.0; // 기본 보정값 0
    const normalizedText = normalizeText(text); // 텍스트 정규화 적용
    const textLower = normalizedText.toLowerCase();
    
    // 문항별 단서 정의 (Q1~Q5, A/B 구분) + 유사어 포함
    const questionKeywords = {
        'Q1': {
            A: ['직접', '써보', '느껴', '만져', '현장', '고객입장', '체험', '실제', '몸으로', '손으로',
                '사용자입장', '유저관점', '유저입장', '실사용', '실전', '실환경', '직접체험', '직접사용'],
            B: ['데이터', '수치', '지표', '로그', '분석', '패턴', '통계', '측정', '정량', '계량',
                '수치분석', '데이터분석', '로그분석', '통계분석', '정량분석', '계량분석']
        },
        'Q2': {
            A: ['빨리', '서둘', '즉시', '먼저', '시간없', '급하', '빠르', '신속', '재빨리', '바로',
                '빠른출시', '신속출시', '즉시출시', '급하게', '서둘러', '재빨리',
                '선점', '시장선점', '시장', '시장 점유', '점유', '시장 점유율',
                '경쟁사보다', '경쟁사 대비', '먼저 내', '빠르게 출시',
                '브랜드 인지도', '인지도', 'first mover', 'first-to-market', 'market advantage', 'market dominance'],
            B: ['검증', '테스트', '브랜드', '품질', '리스크', '신중', '확인', '검토', '완성도', '안전',
                '품질확인', '브랜드이미지', '리스크관리', '신중하게', '완성도확인',
                '브랜드', '리스크', '품질', '검증', '이미지', '평판', '신뢰도', '재출시', '오류', '리뷰']
        },
        'Q3': {
            A: ['일정', '우선순위', '대안', '현실적', '계획', '스케줄', '시간', '효율', '조정', '재배분',
                '일정조정', '우선순위설정', '현실적계획', '시간관리', '효율성'],
            B: ['협업', '공감', '소통', '조율', '배려', '팀워크', '이해', '대화', '조화', '화합',
                '팀협업', '상호이해', '소통강화', '조율과정', '배려심',
                '협업', '공감', '소통', '조율', '배려', '서로', '이해', '의견교환', '대화', '상호존중']
        },
        'Q4': {
            A: ['목표', '조정', '재배분', '효율', '집중', '우선', '중요', '핵심', '최적화', '성과',
                '목표조정', '효율성', '집중도', '우선순위', '핵심과제', '성과관리'],
            B: ['완성도', '지원', '도와', '케어', '품질우선', '보완', '개선', '향상', '발전', '성장',
                '품질완성도', '지원체계', '케어시스템', '개선방안', '향상방안']
        },
        'Q5': {
            A: ['성과', '지표', '유입', '성장', '매출', '퍼센트', '수치', '목표', '달성', '실적',
                '성과지표', '유입증가', '성장률', '매출증가', '달성률', '실적관리'],
            B: ['만족', '경험', '평가', '피드백', '충성', '사용자중심', '감정', '체감', '느낌', '인상',
                '사용자만족', '경험개선', '피드백수집', '충성도', '체감만족',
                '만족', '경험', '피드백', '충성', '추천', '입소문', '지속이용', '사용자 중심', '유저 만족']
        }
    };
    
    const questionId = `Q${scenario}`;
    const keywords = questionKeywords[questionId];
    if (!keywords) return adjustment;
    
    // 현재 세트 단서 확인 (동의어 확장 적용)
    const currentSetKeywords = keywords[selectedOption] || [];
    const expandedKeywords = expandSynonyms(currentSetKeywords);
    
    const currentMatches = expandedKeywords.filter(keyword => textLower.includes(keyword));
    console.log(`🔍 규칙 보정 디버깅 - 원본 텍스트: "${text}"`);
    console.log(`🔍 규칙 보정 디버깅 - 정규화된 텍스트: "${normalizedText}"`);
    console.log(`🔍 규칙 보정 디버깅 - 현재 세트 키워드:`, currentSetKeywords);
    console.log(`🔍 규칙 보정 디버깅 - 매칭된 키워드:`, currentMatches);
    console.log(`🔍 규칙 보정 디버깅 - 현재 보정값: ${adjustment}`);
    
    // 보정 규칙 적용
    if (currentMatches.length > 0) {
        adjustment += 1.0; // 정식 단서 또는 유사어 1개 이상 포함 → +1.0
        console.log(`정식 단서 발견 (${questionId}-${selectedOption}): ${currentMatches.join(', ')}`);
        console.log(`🔍 규칙 보정 디버깅 - 정식 단서 가산 후 보정값: ${adjustment}`);
    }
    
    // NEUTRAL_WORDS 점수 가산 (1번 이상 포함 시 +0.5점)
    const neutralWordMatches = NEUTRAL_WORDS.filter(word => textLower.includes(word));
    if (neutralWordMatches.length > 0) {
        adjustment += 0.5; // NEUTRAL_WORDS 1번 이상 포함 → +0.5
        console.log(`NEUTRAL_WORDS 발견: ${neutralWordMatches.join(', ')}`);
        console.log(`🔍 규칙 보정 디버깅 - NEUTRAL_WORDS 가산 후 보정값: ${adjustment}`);
    }
    
    // 무관 단어 확인 (점심, 날씨, 잡담 등)
    const irrelevantWords = ['점심', '배고파', '날씨', '잡담', '놀이', '게임', '영화', '음악', '여행', '휴가'];
    const irrelevantMatches = irrelevantWords.filter(word => textLower.includes(word));
    if (irrelevantMatches.length > 0) {
        adjustment -= 2.0; // 무관 단어 포함 → -2.0
        console.log(`무관 단어 발견: ${irrelevantMatches.join(', ')}`);
        console.log(`🔍 규칙 보정 디버깅 - 무관 단어 감산 후 보정값: ${adjustment}`);
    }
    
    console.log(`🔍 규칙 보정 최종 보정값: ${adjustment}`);
    return adjustment;
}

// 구체성 점수 계산 (LLM 보정형 v2.1)
function calculateSpecificity(text, scenario, selectedOption) {
    let score = 3.5; // 기본 점수 하향 조정 (형식적 문장 인플레 방지)
    const normalizedText = normalizeText(text); // 텍스트 정규화 적용
    const textLower = normalizedText.toLowerCase();
    
    // 현재 세트 단서가 있는지 확인 (제한 규칙 적용을 위해)
    const hasCurrentSetKeywords = checkCurrentSetKeywords(text, scenario, selectedOption);
    console.log(`🔍 checkCurrentSetKeywords 결과: ${hasCurrentSetKeywords} (문항: Q${scenario}-${selectedOption})`);
    
    // 의사결정 표현이 있는지 먼저 확인 (동의어 확장 적용)
    const decisionExpressions = expandSynonyms(['의사결정']);
    const hasDecisionExpression = decisionExpressions.some(expr => textLower.includes(expr));
    
    // 행동/절차 단어 확인 (의사결정 표현이 없을 때만)
    if (!hasDecisionExpression) {
        // 기존 행동절차 동의어 + 일상적 수행 동사 추가
        const actionWords = expandSynonyms(['행동절차']);
        const dailyActionWords = ['하자', '한다', '진행', '해보자', '해볼게요', '먼저', '해보는 중', '할게요', '하겠습니다', '해보겠습니다'];
        const allActionWords = [...actionWords, ...dailyActionWords];
        
        const hasActionWord = allActionWords.some(word => textLower.includes(word));
        if (hasActionWord) {
            score += 0.8;
            console.log('행동/절차 단어 발견:', allActionWords.filter(word => textLower.includes(word)));
        }
    } else {
        console.log('의사결정 표현 발견으로 행동/절차 단어 가산 제외');
    }
    
    // 대상/맥락 단서 확인
    const contextWords = ['인물', '역할', '상황', '목표', '리스크', '팀', '고객', '사용자', '제품', '서비스'];
    
    // Q2-A 전용 컨텍스트 단서 추가
    if (scenario === 'Q2' && selectedOption === 'A') {
        contextWords.push('시장', '경쟁사', '점유', '선점', '인지도', '시장 점유율', '브랜드 인지도', 'first mover', 'first-to-market');
    }
    
    const matchedContextWords = contextWords.filter(word => textLower.includes(word));
    console.log('🔍 구체성 디버깅 - 원본 텍스트:', text);
    console.log('🔍 구체성 디버깅 - 정규화된 텍스트:', normalizedText);
    console.log('🔍 구체성 디버깅 - 대상/맥락 단서들:', contextWords);
    console.log('🔍 구체성 디버깅 - 매칭된 단서들:', matchedContextWords);
    console.log('🔍 구체성 디버깅 - 현재 점수 (가산 전):', score);
    
    if (matchedContextWords.length > 0) {
        score += 0.8;
        console.log('대상/맥락 단서 발견:', matchedContextWords);
        console.log('🔍 구체성 디버깅 - 가산 후 점수:', score);
    }
    
    // 도구/자료 단어 확인
    const toolWords = ['데이터', '로그', '인터뷰', '설문', '실험', '프로토타입', '도구', '시스템', '플랫폼', '앱'];
    const hasToolWord = toolWords.some(word => textLower.includes(word));
    if (hasToolWord) {
        score += 1.0;
        console.log('도구/자료 단어 발견:', toolWords.filter(word => textLower.includes(word)));
    }
    
    // 0~10 사이로 클램프
    return Math.max(0, Math.min(10, score));
}

// 현재 세트 단서 확인 함수 (핵심 단서 + 부분 일치 모두 포함)
function checkCurrentSetKeywords(text, scenario, selectedOption) {
    const normalizedText = normalizeText(text); // 텍스트 정규화 적용
    const textLower = normalizedText.toLowerCase();
    
    // 핵심 단서 확인
    const questionKeywords = {
        'Q1': {
            A: ['직접', '써보', '느껴', '만져', '현장', '고객입장', '체험', '실제', '몸으로', '손으로',
                '사용자입장', '유저관점', '유저입장', '실사용', '실전', '실환경', '직접체험', '직접사용'],
            B: ['데이터', '수치', '지표', '로그', '분석', '패턴', '통계', '측정', '정량', '계량',
                '수치분석', '데이터분석', '로그분석', '통계분석', '정량분석', '계량분석']
        },
        'Q2': {
            A: ['빨리', '서둘', '즉시', '먼저', '시간없', '급하', '빠르', '신속', '재빨리', '바로',
                '빠른출시', '신속출시', '즉시출시', '급하게', '서둘러', '재빨리',
                '선점', '시장선점', '시장', '시장 점유', '점유', '시장 점유율',
                '경쟁사보다', '경쟁사 대비', '먼저 내', '빠르게 출시',
                '브랜드 인지도', '인지도', 'first mover', 'first-to-market', 'market advantage', 'market dominance'],
            B: ['검증', '테스트', '브랜드', '품질', '리스크', '신중', '확인', '검토', '완성도', '안전',
                '품질확인', '브랜드이미지', '리스크관리', '신중하게', '완성도확인',
                '브랜드', '리스크', '품질', '검증', '이미지', '평판', '신뢰도', '재출시', '오류', '리뷰']
        },
        'Q3': {
            A: ['일정', '우선순위', '대안', '현실적', '계획', '스케줄', '시간', '효율', '조정', '재배분',
                '일정조정', '우선순위설정', '현실적계획', '시간관리', '효율성'],
            B: ['협업', '공감', '소통', '조율', '배려', '팀워크', '이해', '대화', '조화', '화합',
                '팀협업', '상호이해', '소통강화', '조율과정', '배려심',
                '협업', '공감', '소통', '조율', '배려', '서로', '이해', '의견교환', '대화', '상호존중']
        },
        'Q4': {
            A: ['목표', '조정', '재배분', '효율', '집중', '우선', '중요', '핵심', '최적화', '성과',
                '목표조정', '효율성', '집중도', '우선순위', '핵심과제', '성과관리'],
            B: ['완성도', '지원', '도와', '케어', '품질우선', '보완', '개선', '향상', '발전', '성장',
                '품질완성도', '지원체계', '케어시스템', '개선방안', '향상방안']
        },
        'Q5': {
            A: ['성과', '지표', '유입', '성장', '매출', '퍼센트', '수치', '목표', '달성', '실적',
                '성과지표', '유입증가', '성장률', '매출증가', '달성률', '실적관리'],
            B: ['만족', '경험', '평가', '피드백', '충성', '사용자중심', '감정', '체감', '느낌', '인상',
                '사용자만족', '경험개선', '피드백수집', '충성도', '체감만족',
                '만족', '경험', '피드백', '충성', '추천', '입소문', '지속이용', '사용자 중심', '유저 만족']
        }
    };
    
    // 부분 일치 단서 확인
    const weakRelatedWords = {
        'Q1': ['사용자', '고객', '제품', '체험', '경험', '사용', '테스트'],
        'Q2': ['출시', '시장', '경쟁', '타이밍', '속도', '품질'],
        'Q3': ['팀', '갈등', '의견', '조율', '소통', '협력'],
        'Q4': ['업무', '일정', '팀원', '분위기', '야근', '부담'],
        'Q5': ['유저', '목표', '가치', '사용자', '신규', '기존']
    };
    
    const questionId = `Q${scenario}`;
    const keywords = questionKeywords[questionId];
    if (!keywords) return false;
    
    // 1. 핵심 단서 확인 (동의어 확장 적용)
    const currentSetKeywords = keywords[selectedOption] || [];
    const expandedKeywords = expandSynonyms(currentSetKeywords);
    const hasCoreKeywords = expandedKeywords.some(keyword => textLower.includes(keyword));
    
    // 2. 부분 일치 단서 확인
    const weakWords = weakRelatedWords[questionId] || [];
    const hasWeakKeywords = weakWords.some(word => textLower.includes(word));
    
    // 핵심 단서 또는 부분 일치 단서 중 하나라도 있으면 true
    return hasCoreKeywords || hasWeakKeywords;
}

// 표현품질 점수 계산 (LLM 보정형 v2.1)
function calculateExpressionQuality(text, scenario, selectedOption) {
    let score = 5.0; // 기본값 5.0 (표현 품질 기본치 하향)
    const normalizedText = normalizeText(text); // 텍스트 정규화 적용
    const textLower = normalizedText.toLowerCase();
    
    // 현재 세트 단서가 있는지 확인 (제한 규칙 적용을 위해)
    const hasCurrentSetKeywords = checkCurrentSetKeywords(text, scenario, selectedOption);
    
    // 길이 확인 (공백 제외)
    const lengthWithoutSpaces = normalizedText.replace(/\s/g, '').length;
    console.log('🔍 표현품질 디버깅 - 텍스트:', normalizedText);
    console.log('🔍 표현품질 디버깅 - 텍스트 길이 (공백 제외):', lengthWithoutSpaces);
    console.log('🔍 표현품질 디버깅 - 현재 점수 (가산 전):', score);
    
    if (lengthWithoutSpaces >= 10) {
        score += 0.5;
        console.log('적절한 길이 확인');
        console.log('🔍 표현품질 디버깅 - 길이 가산 후 점수:', score);
    }
    
    // 연결어 확인 (1회 한정)
    const connectors = ['그래서', '때문에', '즉', '따라서', '그러므로', '결론적으로', '요약하면',
                       '이라서', '라서', '해서', '므로', '관점에서', '측면에서'];
    const hasConnector = connectors.some(connector => textLower.includes(connector));
    if (hasConnector) {
        score += 0.5;
        console.log('연결어 발견:', connectors.filter(connector => textLower.includes(connector)));
    }
    
    // 문장 구조 일관성 및 논리 흐름 확인
    const sentences = normalizedText.split(/[.!?]/).filter(s => s.trim().length > 0);
    if (sentences.length > 1) {
        // 문장 간 논리적 연결성 확인
        const hasLogicalFlow = sentences.some(sentence => {
            const sentenceLower = sentence.toLowerCase();
            return connectors.some(connector => sentenceLower.includes(connector)) ||
                   sentenceLower.includes('왜냐하면') || sentenceLower.includes('그러나') ||
                   sentenceLower.includes('하지만') || sentenceLower.includes('또한');
        });
        
        if (hasLogicalFlow) {
            score += 0.5;
            console.log('논리적 흐름 확인');
        }
    }
    
    // 연결어와 논리 흐름 가산은 합산 시 최대 +0.5까지만 적용
    const connectorBonus = hasConnector ? 0.5 : 0;
    const flowBonus = sentences.length > 1 && !hasConnector ? 0.5 : 0;
    const totalBonus = Math.min(0.5, connectorBonus + flowBonus);
    score = 5.0 + (lengthWithoutSpaces >= 10 ? 0.5 : 0) + totalBonus;
    
    // 의미 불명확·무관 주제 확인
    const irrelevantWords = ['점심', '배고파', '날씨', '영화', '음악', '게임', '여행', '쇼핑', '운동'];
    const hasIrrelevant = irrelevantWords.some(word => textLower.includes(word));
    if (hasIrrelevant) {
        score -= 3.0;
        console.log('무관 주제 발견');
    }
    
    // 0~10 사이로 클램프
    return Math.max(0, Math.min(10, score));
}

// 검증 에러 표시
function showValidationError(message) {
    // 기존 에러 메시지 제거
    const existingError = document.querySelector('.validation-error');
    if (existingError) {
        existingError.remove();
    }
    
    // 에러 메시지 생성
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error';
    errorDiv.style.cssText = `
        background-color: #fee;
        border: 2px solid #fcc;
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        color: #c33;
        font-size: 14px;
        text-align: center;
        animation: shake 0.5s ease-in-out;
    `;
    errorDiv.textContent = message;
    
    // 입력 필드 위에 에러 메시지 삽입
    const inputContainer = document.querySelector('.input-container');
    inputContainer.parentNode.insertBefore(errorDiv, inputContainer);
    
    // 입력 필드 포커스 및 하이라이트
    const reasonInput = document.getElementById('reasonInput');
    reasonInput.style.borderColor = '#fcc';
    reasonInput.focus();
    
    // 3초 후 에러 메시지 자동 제거
    setTimeout(() => {
        if (errorDiv.parentNode) {
            errorDiv.remove();
        }
        reasonInput.style.borderColor = '';
    }, 3000);
}

// 사용자 이유 제출 (강화형 점수 계산 로직 적용)
async function submitUserReason() {
    const reasonInput = document.getElementById('reasonInput');
    const reason = reasonInput.value.trim();
    
    // 예외처리는 아래 try 블록에서 처리됨
    
    try {
        // 1️⃣ 예외처리 단계 (최우선)
        
        // EMPTY CHECK - 빈 값도 허용하고 null로 처리
        const finalReason = reason || null;
    
        // PROFANITY CHECK - 값이 있을 때만 체크
        if (reason && containsInappropriateLanguage(reason)) {
            showValidationError("부적절한 표현이 섞여있습니다. 다시 작성해주세요.");
        return;
    }
    
        // LENGTH CHECK - 값이 있을 때만 체크
        if (reason) {
            const lengthWithoutSpaces = reason.replace(/\s/g, '').length;
            if (lengthWithoutSpaces < 5 || lengthWithoutSpaces > 50) {
                showValidationError("답변의 길이가 부적절합니다. (5~50자)");
                return;
            }
        }
        
        // 선택한 옵션과 문항 ID 가져오기
        const selectedChoice = userChoices[userChoices.length - 1];
        const rawChoice = selectedChoice.choice;
        
        // 선택지 변환 (1→A, 2→B) - 더 명확한 변환 로직
        let selectedOption;
        if (rawChoice === '1') {
            selectedOption = 'A';
        } else if (rawChoice === '2') {
            selectedOption = 'B';
        } else {
            selectedOption = rawChoice; // 이미 A/B인 경우 그대로 사용
        }
        const questionId = `Q${currentScenario}`;
        
        console.log('🔍 선택지 변환:', { rawChoice, selectedOption, questionId });
        
        console.log('🔍 통합 분석 시작:', { reason: finalReason, selectedOption, questionId });
        
        // 로컬 점수 계산 먼저 수행 (이제 async 함수) - null 값일 때는 점수 계산 건너뛰기
        let scoringResult = { decision: 'accept', score: 0 };
        if (finalReason) {
            scoringResult = await calculateMeaningfulnessScore(finalReason, currentScenario, selectedOption);
        }
        console.log('📊 로컬 점수 계산 결과:', scoringResult);
        
        // 점수가 5.5 미만이면 거부 (null 값이 아닐 때만 체크)
        if (finalReason && scoringResult.decision === 'reject') {
            showValidationError("답변이 다소 모호하거나 선택지 의미와의 연결이 약합니다. 좀 더 구체적으로 작성해주세요.");
            return;
        }
        
        // 로컬 점수가 5.5 이상이면 AI 분석 없이 바로 통과
        console.log('✅ 로컬 점수 통과 - AI 분석 건너뛰고 바로 진행');
        
        const parsedResult = {
            feedback: {
                decision: 'pass',
                message: '좋아요! 답변이 명확하고 문항 의도에 부합합니다.',
                scores: scoringResult.scores,
                judge_confidence: scoringResult.judge_confidence,
                judge_rationale: scoringResult.judge_rationale
            },
            mapping: null
        };
        
        // 로컬 점수가 5.5 미만인 경우 AI 분석 수행 (이제는 이미 위에서 처리됨)
        // scoringResult.decision이 'reject'인 경우는 이미 위에서 처리되었으므로 여기서는 추가 처리 불필요
        
        // 통과된 경우 사용자 이유 저장
        userReasons.push({
            scenario: currentScenario,
            choice: selectedChoice.text,
            reason: finalReason,
            feedback: parsedResult.feedback,
            mapping: parsedResult.mapping,
            scoringResult: scoringResult, // 전체 채점 결과 저장
            timestamp: new Date().toISOString()
        });
        
        console.log('✅ 사용자 이유 저장 완료:', userReasons[userReasons.length - 1]);
        
        // 로컬 스토리지에 사용자 데이터 저장
        const userData = {
            choices: userChoices,
            reasons: userReasons,
            timestamp: new Date().toISOString()
        };
        localStorage.setItem('userTestData', JSON.stringify(userData));
        console.log('💾 사용자 데이터 저장 완료:', userData);
        
        // 입력 프롬프트 숨기기
        document.getElementById('inputPrompt').style.display = 'none';
        
        // 다음 시나리오로 진행
        proceedToNext();
        
    } catch (error) {
        console.error('💥 통합 분석 중 오류:', error);
        alert('분석 중 오류가 발생했습니다. 다시 시도해주세요.');
    }
}

// 통합 피드백 및 매핑 시스템
async function analyzeUserReason(reason, selectedOption, questionId) {
    console.log('🔍 통합 분석 시작:', { reason, selectedOption, questionId });
    
    // 32가지 유형 매핑을 위한 패턴 생성
    const userChoices = JSON.parse(localStorage.getItem('userTestData') || '{}').choices || [];
    const pattern = userChoices.map(choice => choice.choice).join('');
    
    const messages = [
        {
            role: "system",
            content: `당신은 "피드백 생성 및 예외처리 + 32유형 매핑" 시스템입니다.

==============================
[0] 입력/출력 계약 (I/O Contract)
==============================
■ 입력(JSON):
- 다음 중 하나 이상을 포함할 수 있습니다.
  1) reason_input: 단일 문항(reason) 분석용
     {
       "question_id": "Q1"~"Q5",
       "selected_option": "A" | "B",
       "reason": "문자열"
     }
  2) selections 또는 pattern: 5문항 전체 선택 기반 32유형 매핑용
     - selections: {"Q1":"A|B","Q2":"A|B","Q3":"A|B","Q4":"A|B","Q5":"A|B"}
     - 또는 pattern: "AAAAA" ~ "BBBBB" (정확히 5자, 각 자리 A/B)

■ 출력(JSON):
{
  "feedback": null | { ...피드백 출력 스키마... },
  "mapping": null | {
    "pattern": "A/B 5자",
    "type_name": "매핑된 유형명",
    "type_index": 1~32 (선택사항),
    "details": {
      "short_intro": "...",
      "long_intro": "...",
      "strengths": ["..."],
      "areas_to_improve": ["..."],
      "best_match_pm": "...",
      "contrasting_pm": "..."
    }
  }
}

==============================
[1] 피드백 생성 및 예외처리 규칙
==============================

당신은 "피드백 생성 및 예외처리 시스템"입니다.  
입력은 다음 JSON 형식으로 주어집니다:

{
  "question_id": "Q1" ~ "Q5",
  "selected_option": "A" | "B",
  "reason": "문자열"
}

아래의 규칙을 순서대로 적용하세요.

-----------------------------------------
1️⃣ CLEANUP 단계
-----------------------------------------
- reason 문자열에서 특수문자, 이모티콘, 구두점(.,!?~@#$/%^&* 등)을 제거합니다.
- 연속된 공백은 하나로 축소합니다.
- 띄어쓰기, 맞춤법, 문법 오류는 무시합니다.
- 길이 계산 시 공백 제외 기준(length_no_space)을 사용합니다.

-----------------------------------------
2️⃣ EMPTY CHECK
-----------------------------------------
- length_no_space == 0 → reject("EMPTY", "답변이 입력되지 않았습니다. 다시 작성해주세요.")

-----------------------------------------
3️⃣ PROFANITY CHECK (개선안 v1.2 + Whitelist 오탐 방지)
-----------------------------------------
- 비속어나 모욕적 표현이 포함되면 → reject("PROFANITY", "부적절한 표현이 섞여있습니다. 다시 작성해주세요.")
- 탐지 원칙:
  • 원문(reason) 기준으로 검사 (공백 제거·자모 분해본으로 검사하지 않는다)
  • 대소문자, 특수기호, 띄어쓰기가 섞여도 탐지
  • 단어 경계 기반 탐지로 일반 단어 내부 부분 일치 오탐 방지
- 정규식: (?<![가-힣A-Za-z])(씨\s발|시\s발|ㅆ\sㅂ|병\s신|ㅂ\sㅅ|개\s같|좆|존\s*나|fuck|shit|bitch|asshole)(?![가-힣A-Za-z])
- 플래그: i (대소문자 무시), u (유니코드)
- Whitelist (오탐 방지): ["현황","도출","개선","파악","결정","출시","분석","검토","측정","도전","기능","제품","서비스","사용자","시장","점유"]
- 판정 절차:
  1) reason_original에 대해 위 정규식으로 1차 검사
  2) 매칭되면 Whitelist 단어 포함 여부 확인
     - 포함 O → 오탐 가능성 → PROFANITY 미적용(통과)
     - 포함 X → PROFANITY 적용(reject)
- 예시:
  • "현황을 파악해 개선 방안을 도출하려고" → ✅ 통과
  • "시  발 이라도 하자" / "ㅆ ㅂ 진짜" / "f*ck this" → ❌ reject
  • "개같이 열심히" → ❌ reject

-----------------------------------------
4️⃣ LENGTH CHECK
-----------------------------------------
- 공백 제외 길이 < 5 또는 > 50 → reject("LENGTH", "답변의 길이가 부적절합니다. (5~50자)")

-----------------------------------------
5️⃣ 유의미도 점수 계산
-----------------------------------------
✅ 모든 검사를 통과했다면 아래 점수를 계산합니다.

초기값:
 - semantic_relevance = 3.0      // 기본치 원래대로 롤백 (5.0 → 3.0)
 - specificity = 3.5             // 형식 가산만으로 통과되는 현상 억제
 - expression_quality = 5.0      // 표현 품질 기본치 하향

총합 계산:
 총합 = 의미일치도*0.6 + 구체성*0.25 + 표현품질*0.15  
 PASS 기준: 총합 ≥ 5.5           // 통과 문턱 조정 (6.0 → 5.8 → 5.0 → 5.5) - 의미 기반 답변 더 많이 통과

-----------------------------------------
6️⃣ 세부 점수 규칙
-----------------------------------------

🧩 의미일치도 (semantic_relevance) - LLM 중심

LLM이 우선 의미 판단을 수행하고, 규칙 점수는 "보정값(rule_adjustment)"으로만 반영한다.

final_semantic = (llm_semantic * 0.8) + (rule_adjustment * 0.2)

보정 규칙 (rule_adjustment):
- 현재 문항·선택(Qx-A/B)의 정식 단서 또는 유사어 1개 이상 포함 → +1.0
- NEUTRAL_WORDS(현황, 문제, 도출, 분석, 개선, 확인, 점검, 검토, 정리, 파악, 진행, 대응, 조율 등) 1번 이상 포함 → +0.5
- 무관 단어(점심, 날씨, 잡담 등) 포함 → -2.0
- LLM이 "일상형이지만 의미 일치"로 판단한 경우(예: "사용자 입장에서 보면 그래야지") → semantic_relevance ≥ 7.0
- 0~10 사이로 클램프

 (참고) 단서 세트 예시:
- Q1-A: 직접, 써보, 느껴, 만져, 현장, 고객입장  
- Q1-B: 데이터, 수치, 지표, 로그, 분석, 패턴  
- Q2-A: 빨리, 서둘, 즉시, 먼저, 시간없, 급하, 빠르  
- Q2-B: 검증, 테스트, 브랜드, 품질, 리스크, 신중  
- Q3-A: 일정, 우선순위, 대안, 현실적, 계획  
- Q3-B: 협업, 공감, 소통, 조율, 배려  
- Q4-A: 목표, 조정, 재배분, 효율, 집중  
- Q4-B: 완성도, 지원, 도와, 케어, 품질우선  
- Q5-A: 성과, 지표, 유입, 성장, 매출, 퍼센트  
- Q5-B: 만족, 경험, 평가, 피드백, 충성, 사용자중심

🧩 구체성 (specificity)
 - 행동/절차 단어: 하자, 한다, 진행, 분석, 정리 → +0.8  
   ⚠️ 단, reason에 의사결정 표현(~하자/해야/먼저/진행 등)이 이미 포함된 경우 → 이 항목 가산 제외(중복 방지)
 - 대상/맥락 단서: 인물, 역할, 상황, 목표, 리스크 → +0.8
 - 도구/자료: 데이터, 로그, 인터뷰, 설문, 실험, 프로토타입 → +1.0
 - 논리 연결어(왜냐하면, 그래서, 때문에, 즉, 결론적으로) → ❌ 제외  // 표현품질에서만 반영
 - 여러 항목 동시 존재 시 누적 가능(최대 +3.0)
 - (제한 규칙 제거) 현재 세트 단서 제한 없음  // 사용자 요청으로 제한 규칙 비활성화
- 0~10 사이로 클램프

🧩 표현품질 (expression_quality)
 - 기본값 5.0
 - 길이(공백 제외) ≥ 10 → +0.5
 - 연결어(그래서/때문에/즉 등) 존재 → +0.5 (1회 한정)  // 중복 가산 금지
 - 문장 구조 일관·논리 흐름 명확 → +0.5
 - 의미 불명확·무관 주제 포함 시 → -3.0
 - (제한 규칙 제거) 현재 세트 단서 제한 없음  // 사용자 요청으로 제한 규칙 비활성화
- 0~10 사이로 클램프

-----------------------------------------
7️⃣ 최종 판정
-----------------------------------------
 - 총합(weighted_total) < 5.5 → 
   reject("LOW_SIGNIFICANCE", "답변이 다소 모호하거나 선택지 의미와의 연결이 약합니다. 좀 더 구체적으로 작성해주세요.")
 - 총합(weighted_total) ≥ 5.5 → pass
 
 (구체적 로직 예시)
 if (weighted_total < 5.5) {
   decision = "reject";
   reject_reason = "LOW_SIGNIFICANCE";
   message = "답변이 다소 모호하거나 선택지 의미와의 연결이 약합니다. 좀 더 구체적으로 작성해주세요.";
 } else {
   decision = "pass";
   reject_reason = null;
   message = "좋아요! 답변이 명확하고 문항 의도에 부합합니다.";
 }

-----------------------------------------
8️⃣ 출력(JSON 형식)
-----------------------------------------
결과는 반드시 아래 형식으로 출력합니다.

{
  "decision": "pass" | "reject",
  "reject_reason": null | "EMPTY" | "PROFANITY" | "LENGTH" | "LOW_SIGNIFICANCE",
  "scores": {
    "semantic_relevance": 0~10,
    "specificity": 0~10,
    "expression_quality": 0~10,
    "weighted_total": 0~10
  },
  "message": "사용자에게 보여줄 피드백 문장",
  "outputs": {
    "summary": "40~60자 요약 문장",
    "strengths": ["40~60자 문장 최대 3개"],
    "areas_to_improve": ["40~60자 문장 최대 3개"]
  }
}

==============================
[2] 32유형 매핑 규칙
==============================
- pattern → analyzing.js 내 1:1 매핑 테이블에서 해당 유형을 조회
- 결과 객체는 아래 형태로 구성:
{
  "pattern": "ABBAB",
  "type_name": "예: 싹싹 김치 형",
  "details": {
    "short_intro": "...",
    "long_intro": "...",
    "strengths": ["...", "..."],
    "areas_to_improve": ["...", "..."],
    "best_match_pm": "...",
    "contrasting_pm": "..."
  }
}

==============================
[3] 최종 출력 포맷(반드시 준수)
==============================
- 항상 다음 최상위 JSON 키를 포함:
{
  "feedback": null | {...피드백 출력 스키마...},
  "mapping": null | {...매핑 출력 스키마...}
}
- 어느 한 쪽 입력이 없으면 해당 키에 null을 넣어 반환`
        },
        {
            role: "user",
            content: `{
  "reason_input": {
    "question_id": "${questionId}",
    "selected_option": "${selectedOption}",
    "reason": "${reason}"
  },
  "pattern": "${pattern}"
}`
        }
    ];
    
    const requestBody = {
        model: "gpt-3.5-turbo",
        messages: messages,
        max_tokens: 1500,
        temperature: 0.7
    };
    
    const response = await fetch(OPENAI_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
        throw new Error(`API 호출 실패: ${response.status}`);
    }
    
    const data = await response.json();
    
    // 토큰 사용량 로깅
    if (data.usage) {
        console.log(`📊 통합 분석 토큰 사용량:`);
        console.log(`  - 입력 토큰: ${data.usage.prompt_tokens}`);
        console.log(`  - 출력 토큰: ${data.usage.completion_tokens}`);
        console.log(`  - 총 토큰: ${data.usage.total_tokens}`);
    }
    
    return data.choices[0].message.content;
}

// OpenAI API 호출 함수
async function callOpenAI(userChoice) {
    const messages = [
        {
            role: "system",
            content: "당신은 PM 듬이의 조언자입니다. 사용자의 선택에 따라 다음 상황을 제시하고, PM으로서의 성장을 도와주세요. 한국어로 응답하세요."
        },
        {
            role: "user",
            content: `현재 상황: 회사 상품 매출 급감 문제 해결 중. 사용자 선택: ${userChoice}`
        }
    ];
    
    const requestBody = {
        model: "gpt-3.5-turbo",
        messages: messages,
        max_tokens: 500,
        temperature: 0.7
    };
    
    const response = await fetch(OPENAI_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
        throw new Error(`API 호출 실패: ${response.status}`);
    }
    
    const data = await response.json();
    
    // 토큰 사용량 로깅
    if (data.usage) {
        console.log(`📊 일반 AI 응답 토큰 사용량:`);
        console.log(`  - 입력 토큰: ${data.usage.prompt_tokens}`);
        console.log(`  - 출력 토큰: ${data.usage.completion_tokens}`);
        console.log(`  - 총 토큰: ${data.usage.total_tokens}`);
    }
    
    return data.choices[0].message.content;
}

// AI 응답 처리
function handleAIResponse(response) {
    console.log('AI 응답:', response);
    
    // 다음 시나리오로 업데이트
    currentScenario++;
    updateScenario();
    
    // 새로운 선택지 생성 (실제로는 AI 응답에 따라 동적으로 생성)
    updateChoices();
}

// 시나리오 업데이트
function updateScenario() {
    const scenarios = [
        {
            title: "아침부터 큰일이 났다는 소식이...",
            description: "최근 밀크T 이용 학생 수가 갑자기 줄었다는 것이다.<br>듬이는 원인을 찾아야 한다!<br>어떻게 접근할까?",
            character: "char4.png"
        },
        {
            title: "다행히 원인을 찾아 빠르게 수정했다!",
            description: "이제는 새로 추가될 AI 추천 기능 회의 시간.<br>경쟁사보다 먼저 출시할지, 완성도를 높일지 고민된다.<br>어떤 전략이 맞을까?",
            character: "char5.png"
        },
        {
            title: "디자이너와 개발자가 또 부딪쳤다.",
            description: "\"애니메이션 효과를 더 넣자!\" vs \"지금 일정으론 힘들어요!\"<br>듬이는 둘 사이의 갈등을 해결해야 한다.<br>어떻게 말할까?",
            character: "char6.png"
        },
        {
            title: "어머나! 런칭 일정이 갑자기 일주일 빨라졌다.",
            description: "팀원들은 피곤해 보이고, 분위기가 가라앉았다.<br>듬이는 팀을 다시 힘내게 하고 싶다.<br>어떻게 이끌까?",
            character: "char7.png"
        },
        {
            title: "퇴근 직전, 부문장님이 듬이를 부르셨다.",
            description: "\"듬이 씨, 이번 밀크T 리뉴얼의 핵심 목표가 뭐죠?\"<br>갑작스러운 질문에 잠시 멈칫한다.<br>어떻게 답할까?",
            character: "char8.png"
        }
    ];
    
    if (currentScenario <= scenarios.length) {
        const scenario = scenarios[currentScenario - 1];
        document.querySelector('.scenario-title').textContent = scenario.title;
        document.querySelector('.scenario-description').innerHTML = scenario.description;
        
        // 캐릭터 이미지 업데이트
        if (scenario.character) {
            document.querySelector('.character-image').src = `images/avatars/${scenario.character}`;
        }
        
        // 선택지 업데이트
        updateChoices();
        
        // 시간 업데이트
        updateTime();
        
        // 진행 상황 업데이트
        updateProgress();
    } else {
        // 모든 시나리오 완료 - 분석 중 화면으로 이동
        window.location.href = 'analyzing.html';
    }
}

// 선택지 업데이트
function updateChoices() {
    const choiceSets = [
        [
            "직접 밀크T를 써보며 불편한 점을 찾아보자.",
            "데이터로 어떤 단계에서 이탈이 생겼는지 확인하자."
        ],
        [
            "일단 빨리 내서 시장 반응을 먼저 보자.",
            "충분히 테스트해서 완성도를 높이자."
        ],
        [
            "\"일정 안에서 가능한 대안을 먼저 정리해봅시다.\"",
            "\"서로 입장에서 한 번 더 생각해보고 조율해봐요.\""
        ],
        [
            "\"목표를 조금 줄이고, 일정을 다시 나눠봅시다.\"",
            "\"완성도를 먼저 챙깁시다. 일정은 제가 같이 조정할게요.\""
        ],
        [
            "\"새로운 학습자 수를 10% 이상 늘리는 겁니다!\"",
            "\"학생 만족도를 80% 이상으로 올리는 게 목표입니다!\""
        ]
    ];
    
    if (currentScenario <= choiceSets.length) {
        const choices = choiceSets[currentScenario - 1];
        const choiceButtons = document.querySelectorAll('.choice-button');
        
        choiceButtons.forEach((button, index) => {
            button.textContent = choices[index] || "다음 단계로 진행";
            button.classList.remove('selected');
        });
    }
}

// 시간 업데이트
function updateTime() {
    const timeElement = document.querySelector('.time');
    const times = [
        '09:00 AM',
        '09:55 AM',
        '11:00 AM',
        '14:00 PM',
        '17:00 PM'
    ];
    
    if (currentScenario <= times.length) {
        timeElement.textContent = times[currentScenario - 1];
    }
}

// 진행 상황 업데이트
function updateProgress() {
    const segments = document.querySelectorAll('.progress-segment');
    
    // 세그먼트 상태 업데이트
    segments.forEach((segment, index) => {
        segment.classList.remove('completed', 'current');
        
        if (index < currentScenario - 1) {
            segment.classList.add('completed');
        } else if (index === currentScenario - 1) {
            segment.classList.add('current');
        }
    });
}

// 로딩 표시
function showLoading() {
    document.getElementById('loadingSection').style.display = 'block';
    document.querySelector('.choices-section').style.display = 'none';
}

// 로딩 숨김
function hideLoading() {
    document.getElementById('loadingSection').style.display = 'none';
    document.querySelector('.choices-section').style.display = 'flex';
}

// 에러 표시
function showError(message) {
    alert(message);
}

// 이유 분석 결과 처리
function handleReasonAnalysis(analysis) {
    console.log('PM 유형 분석 결과:', analysis);
    
    // 분석 결과를 시나리오에 표시
    const scenarioSection = document.querySelector('.scenario-section');
    scenarioSection.innerHTML = `
        <div class="analysis-result">
            <h3 class="analysis-title">🎯 PM 유형 분석 결과</h3>
            <div class="analysis-content">
                <p>${analysis}</p>
            </div>
            <div class="user-reasons-summary">
                <h4>📝 입력하신 이유들:</h4>
                <ul>
                    ${userReasons.map(reason => `<li>${reason.reason}</li>`).join('')}
                </ul>
            </div>
            <button onclick="proceedToNext()" class="action-button primary">다음 단계로</button>
        </div>
    `;
    
    // 다른 섹션들 숨기기
    document.querySelector('.character-section').style.display = 'none';
    document.querySelector('.choices-section').style.display = 'none';
    document.querySelector('.action-buttons-section').style.display = 'none';
}

// UI 초기화
function resetUI() {
    // 모든 섹션을 원래 상태로 복원
    document.getElementById('initialChoices').style.display = 'flex';
    document.getElementById('inputPrompt').style.display = 'none';
    document.querySelector('.character-section').style.display = 'block';
    
    // 선택된 버튼 스타일 제거
    const selectedButtons = document.querySelectorAll('.choice-button.selected');
    selectedButtons.forEach(button => {
        button.classList.remove('selected');
    });
    
    // 입력 필드 초기화
    const reasonInput = document.getElementById('reasonInput');
    if (reasonInput) {
        reasonInput.value = '';
    }
}

// 게임 종료
// 종합 분석 화면
async function showFinalAnalysis() {
    const scenarioSection = document.querySelector('.scenario-section');
    scenarioSection.innerHTML = `
        <div class="final-analysis">
            <h3>🎯 PM 유형 분석 중...</h3>
            <p>모든 답변을 종합하여 분석하고 있습니다.</p>
            <div class="loading-spinner"></div>
        </div>
    `;
    
    // 다른 섹션들 숨기기
    document.querySelector('.choices-section').style.display = 'none';
    document.querySelector('.action-buttons-section').style.display = 'none';
    document.querySelector('.character-section').style.display = 'none';
    
    try {
        // 종합 분석 요청
        const analysis = await analyzeAllReasons();
        
        // 분석 결과 표시
        displayFinalAnalysis(analysis);
        
    } catch (error) {
        console.error('종합 분석 오류:', error);
        showAnalysisError();
    }
}

// 모든 이유 종합 분석
async function analyzeAllReasons() {
    const allReasons = userReasons.map(reason => 
        `시나리오 ${reason.scenario}: ${reason.reason}`
    ).join('\n');
    
    const messages = [
        {
            role: "system",
            content: "당신은 PM 전문가입니다. 사용자가 5개 시나리오에서 입력한 모든 답변을 종합하여 PM 유형을 분석하고, 장단점과 개선 방향을 제시해주세요. 한국어로 응답하세요."
        },
        {
            role: "user",
            content: `사용자가 입력한 모든 답변들:\n${allReasons}\n\n이 모든 답변을 종합하여 PM 유형을 분석하고, 장단점과 개선 방향을 제시해주세요.`
        }
    ];
    
    const requestBody = {
        model: "gpt-3.5-turbo",
        messages: messages,
        max_tokens: 1000,
        temperature: 0.7
    };
    
    const response = await fetch(OPENAI_API_URL, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
        },
        body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
        throw new Error(`API 호출 실패: ${response.status}`);
    }
    
    const data = await response.json();
    return data.choices[0].message.content;
}

// 최종 분석 결과 표시
function displayFinalAnalysis(analysis) {
    const scenarioSection = document.querySelector('.scenario-section');
    scenarioSection.innerHTML = `
        <div class="final-analysis-result">
            <h3>🎯 PM 유형 분석 결과</h3>
            <div class="analysis-content">
                ${analysis}
            </div>
            <div class="user-reasons-summary">
                <h4>📝 입력한 답변들:</h4>
                <ul>
                    ${userReasons.map((reason, index) => 
                        `<li><strong>시나리오 ${reason.scenario}:</strong> ${reason.reason}</li>`
                    ).join('')}
                </ul>
            </div>
            <button onclick="location.href='index.html'" class="action-button primary">메인으로 돌아가기</button>
        </div>
    `;
}

// 분석 오류 표시
function showAnalysisError() {
    const scenarioSection = document.querySelector('.scenario-section');
    scenarioSection.innerHTML = `
        <div class="analysis-error">
            <h3>❌ 분석 오류</h3>
            <p>분석 중 오류가 발생했습니다. 다시 시도해주세요.</p>
            <button onclick="location.reload()" class="action-button primary">다시 시도</button>
            <button onclick="location.href='index.html'" class="action-button secondary">메인으로 돌아가기</button>
        </div>
    `;
}

// API 키 에러 표시
function showAPIKeyError() {
    const scenarioSection = document.querySelector('.scenario-section');
    scenarioSection.innerHTML = `
        <div class="api-key-error">
            <h3>🔐 API 키 로드 실패</h3>
            <p>.env 파일에서 OPENAI_API 키를 찾을 수 없습니다.</p>
            <div class="error-steps">
                <h4>📋 확인사항:</h4>
                <ul>
                    <li>.env 파일이 프로젝트 루트에 있는지 확인</li>
                    <li>OPENAI_API=sk-... 형식으로 저장되어 있는지 확인</li>
                    <li>브라우저 개발자 도구 콘솔에서 오류 메시지 확인</li>
                </ul>
            </div>
            <button onclick="location.reload()" class="action-button primary">다시 시도</button>
            <button onclick="location.href='index.html'" class="action-button secondary">메인으로 돌아가기</button>
        </div>
    `;
    
    // 다른 섹션들 숨기기
    document.querySelector('.character-section').style.display = 'none';
    document.querySelector('.choices-section').style.display = 'none';
}

// API 키 검증
function validateAPIKey() {
    if (!OPENAI_API_KEY) {
        console.warn('OpenAI API 키가 로드되지 않았습니다!');
        return false;
    }
    return true;
}

// 디버깅용 점수 계산 테스트 함수 (새로운 LLM-Judge 버전)
async function testScoring() {
    console.log('🧪 LLM-Judge 기반 하이브리드 점수 계산 테스트 시작');
    
    // 테스트 케이스 1: Q1-A 선택, 현장/고객입장 포함
    const testCase1 = {
        text: '현장에서 고객입장으로 결제까지 체험해 보겠습니다.',
        scenario: 1,
        selectedOption: 'A'
    };
    
    console.log('테스트 케이스 1:', testCase1);
    const result1 = await calculateMeaningfulnessScore(testCase1.text, testCase1.scenario, testCase1.selectedOption);
    console.log('테스트 케이스 1 결과:', result1);
    
    // 테스트 케이스 2: Q1-B 선택, 데이터/분석 포함
    const testCase2 = {
        text: '데이터를 분석해서 이탈 지점을 찾아보겠습니다.',
        scenario: 1,
        selectedOption: 'B'
    };
    
    console.log('테스트 케이스 2:', testCase2);
    const result2 = await calculateMeaningfulnessScore(testCase2.text, testCase2.scenario, testCase2.selectedOption);
    console.log('테스트 케이스 2 결과:', result2);
    
    // 테스트 케이스 3: 모호한 답변
    const testCase3 = {
        text: '그냥 해보자',
        scenario: 1,
        selectedOption: 'A'
    };
    
    console.log('테스트 케이스 3:', testCase3);
    const result3 = await calculateMeaningfulnessScore(testCase3.text, testCase3.scenario, testCase3.selectedOption);
    console.log('테스트 케이스 3 결과:', result3);
    
    // 테스트 케이스 4: 다른 선택지 단서 포함 (감점 없음)
    const testCase4 = {
        text: '현장에서 고객입장으로 체험해보겠습니다.',
        scenario: 1,
        selectedOption: 'B' // B 선택했는데 A 단서 포함
    };
    
    console.log('테스트 케이스 4 (다른 선택지 단서 테스트):', testCase4);
    const result4 = await calculateMeaningfulnessScore(testCase4.text, testCase4.scenario, testCase4.selectedOption);
    console.log('테스트 케이스 4 결과:', result4);
    
    // 테스트 케이스 5: 부분 일치만 있는 경우
    const testCase5 = {
        text: '고객 관점에서 체험해보겠습니다.',
        scenario: 1,
        selectedOption: 'A' // A 선택, 부분 일치 단서만 포함
    };
    
    console.log('테스트 케이스 5 (부분 일치 테스트):', testCase5);
    const result5 = await calculateMeaningfulnessScore(testCase5.text, testCase5.scenario, testCase5.selectedOption);
    console.log('테스트 케이스 5 결과:', result5);
    
    console.log('🧪 LLM-Judge 기반 하이브리드 점수 계산 테스트 완료');
}

// 전역 함수로 등록 (브라우저 콘솔에서 호출 가능)
window.testScoring = testScoring;
